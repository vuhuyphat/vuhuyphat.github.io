name: UCAN Upload ‚Üí Auto‚ÄëIPNS (One‚ÄëPaste)

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]
    paths:
      - "site/**"
      - ".github/workflows/auto-ipns-w3.yml"
  schedule:
    - cron: "0 */6 * * *"   # ch·∫°y m·ªói 6 gi·ªù

permissions:
  contents: read

concurrency:
  group: ipns-publish
  cancel-in-progress: true

jobs:
  publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install minimal deps
        run: |
          mkdir -p .onepaste && cd .onepaste
          npm init -y >/dev/null
          npm i @web3-storage/w3up-client @ucanto/principal @web3-storage/w3name mime dotenv >/dev/null

      - name: Create uploader (UCAN ‚Üí IPFS ‚Üí IPNS)
        run: |
          cat > .onepaste/upload_ipns.mjs <<'EOF'
          import 'dotenv/config'
          import fs from 'fs'
          import path from 'path'
          import mime from 'mime'
          import * as Client from '@web3-storage/w3up-client'
          import * as Principal from '@ucanto/principal/ed25519'
          import * as Name from '@web3-storage/w3name'

          const KEY_PATH = '.w3name.key'
          const exists = p => { try { fs.accessSync(p); return true } catch { return false } }

          async function collectFiles(inputPath){
            const stat = fs.statSync(inputPath)
            if (stat.isDirectory()){
              const files=[], root=inputPath
              ;(function walk(dir){
                for (const n of fs.readdirSync(dir)){
                  const p=path.join(dir,n), s=fs.statSync(p)
                  if (s.isDirectory()) walk(p)
                  else{
                    const rel=path.relative(root,p).split(path.sep).join('/')
                    const type=mime.getType(p)||'application/octet-stream'
                    files.push(new File([fs.readFileSync(p)], rel, { type }))
                  }
                }
              })(inputPath)
              if(!files.length) throw new Error('Th∆∞ m·ª•c tr·ªëng.')
              return {kind:'dir', files}
            } else {
              const name=path.basename(inputPath)
              const type=mime.getType(inputPath)||'application/octet-stream'
              return {kind:'file', files:[new File([fs.readFileSync(inputPath)], name, {type})]}
            }
          }

          async function uploadWithUCAN(src){
            // nh·∫≠n secrets (∆∞u ti√™n bi·∫øn 1, fallback bi·∫øn 2)
            const UCAN     = process.env.WEB3_STORAGE_UCAN || process.env.WEB3_STORAGE_KEY
            const SPACE_DID= process.env.WEB3_SPACE_DID    || process.env.WEB3_SPACE_KEY
            if(!UCAN||!SPACE_DID) throw new Error('Thi·∫øu UCAN ho·∫∑c SPACE_DID. H√£y thi·∫øt l·∫≠p secrets WEB3_STORAGE_UCAN/WEB3_STORAGE_KEY v√† WEB3_SPACE_DID/WEB3_SPACE_KEY.')

            const principal = await Principal.generate()
            const client = await Client.create({ principal })
            const space = await client.addSpace(SPACE_DID)
            await client.setCurrentSpace(space.did())

            const proof = await Client.importDelegation(UCAN)
            await client.addProof(proof)

            const {kind, files}=await collectFiles(src)
            let cid
            if(kind==='dir'){
              cid = await client.uploadDirectory(files, { onShardStored: ({cid}) => console.log('‚Ä¢ stored shard:', cid.toString()) })
            } else {
              cid = await client.uploadFile(files[0], { onShardStored: ({cid}) => console.log('‚Ä¢ stored shard:', cid.toString()) })
            }
            const c=cid.toString()
            console.log('\\n‚úÖ Upload xong  ‚Üí CID:', c)
            console.log('Gateway:', `https://w3s.link/ipfs/${c}`)
            return c
          }

          async function loadOrCreateName(){
            const envKey=(process.env.W3NAME_KEY||'').trim()
            if(envKey){ console.log('üîê D√πng W3NAME_KEY t·ª´ secrets.'); return await Name.from(Buffer.from(envKey,'base64')) }
            if(exists(KEY_PATH)){ console.log('üîê D√πng kho√° IPNS ƒë√£ l∆∞u t·ª´ run tr∆∞·ªõc.'); return await Name.from(Buffer.from(fs.readFileSync(KEY_PATH,'utf8').trim(),'base64')) }
            const name = await Name.create()
            const b64 = Buffer.from(name.key.bytes).toString('base64')
            fs.writeFileSync(KEY_PATH,b64)
            console.log('üÜï T·∫°o IPNS name:', name.toString())
            console.log('‚ö†Ô∏è H√£y l∆∞u W3NAME_KEY (base64) t·ª´ artifact .w3name.key sau run ƒë·∫ßu.')
            return name
          }

          async function publishIPNS(cid){
            const name = await loadOrCreateName()
            const value = `/ipfs/${cid}`
            let rev
            try { rev = await Name.increment(await Name.resolve(name), value) }
            catch { rev = await Name.v0(name, value) }
            await Name.publish(rev, name.key)
            const ipns = name.toString()
            console.log('\\nüîó IPNS c·∫≠p nh·∫≠t!')
            console.log('IPNS:', ipns)
            console.log('Gateway:', `https://w3s.link/ipns/${ipns}`)
            // ghi file info cho steps sau
            fs.writeFileSync('ipns.txt', ipns)
            fs.writeFileSync('cid.txt', cid)
          }

          async function main(){
            const SRC = process.env.UPLOAD_PATH || 'site'
            if(!exists(SRC)){
              fs.mkdirSync('site', {recursive:true})
              fs.writeFileSync('site/index.html','<h1>Hello IPNS</h1><p>Auto publish from GitHub Actions.</p>')
            }
            const cid = await uploadWithUCAN(SRC)
            await publishIPNS(cid)
          }
          main().catch(e=>{ console.error('\\n‚ùå L·ªói:', e?.message||e); process.exit(1) })
          EOF

      - name: Run ‚Ä¢ Upload + IPNS
        env:
          # nh·∫≠n t·ª´ c·∫£ 2 c√°ch ƒë·∫∑t t√™n secrets c·ªßa b·∫°n
          WEB3_STORAGE_UCAN: ${{ secrets.WEB3_STORAGE_UCAN || secrets.WEB3_STORAGE_KEY }}
          WEB3_SPACE_DID:   ${{ secrets.WEB3_SPACE_DID    || secrets.WEB3_SPACE_KEY   }}
          W3NAME_KEY:       ${{ secrets.W3NAME_KEY }}
          UPLOAD_PATH:      site             # ƒë·ªïi th√†nh dist/public n·∫øu mu·ªën
        run: node .onepaste/upload_ipns.mjs

      - name: Upload artifacts ‚Ä¢ IPNS/CID (+ key n·∫øu v·ª´a t·∫°o)
        uses: actions/upload-artifact@v4
        with:
          name: ipns-publish-output
          path: |
            ipns.txt
            cid.txt
            .w3name.key
          if-no-files-found: ignore

      - name: Summary
        run: |
          echo "### IPNS Publish Result" >> $GITHUB_STEP_SUMMARY
          test -f cid.txt && echo "- **CID:** \`$(cat cid.txt)\`" >> $GITHUB_STEP_SUMMARY || true
          test -f ipns.txt && echo "- **IPNS:** \`$(cat ipns.txt)\`" >> $GITHUB_STEP_SUMMARY || true
          echo "- Gateway (IPNS): https://w3s.link/ipns/$(cat ipns.txt 2>/dev/null || echo '<ch∆∞a c√≥>')" >> $GITHUB_STEP_SUMMARY
