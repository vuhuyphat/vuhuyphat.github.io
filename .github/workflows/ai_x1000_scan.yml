name: AI X1000 ‚Äì Scan & Broadcast

on:
  schedule:
    - cron: "*/10 * * * *"   # ch·∫°y m·ªói 10 ph√∫t (UTC)
  workflow_dispatch:

# T·ªëi thi·ªÉu quy·ªÅn, cho ph√©p ghi ƒë·ªÉ commit data
permissions:
  contents: write

# Tr√°nh ch·ªìng ch·∫°y khi l·∫ßn tr∆∞·ªõc ch∆∞a xong
concurrency:
  group: ai-x1000-auto
  cancel-in-progress: true

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build latest.json (scan multiple sources + score)
        shell: bash
        run: |
          node - <<'NODE'
          import fs from 'fs';

          // ------------------ ti·ªán √≠ch chung ------------------
          const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));

          async function safeGet(url, {retries=3, backoff=800, timeout=10000, headers={}} = {}) {
            for (let i=0;i<retries;i++){
              const ctrl = new AbortController();
              const to = setTimeout(()=>ctrl.abort(), timeout);
              try {
                const res = await fetch(url, {
                  headers: {
                    "User-Agent": "AI-X1000/1.0 (+github actions)",
                    "Accept": "application/json",
                    ...headers
                  },
                  signal: ctrl.signal
                });
                clearTimeout(to);
                if (!res.ok) throw new Error(res.status+" "+res.statusText);
                return await res.json();
              } catch (e) {
                if (i===retries-1) throw e;
                await sleep(backoff * (i+1));
              }
            }
          }

          // ------------------ ƒë·ªçc c·∫•u h√¨nh ------------------
          function readConfig() {
            const candidates = ["config.json", "c·∫•u h√¨nh.json", "cau hinh.json"];
            for (const name of candidates){
              if (fs.existsSync(name)) {
                return JSON.parse(fs.readFileSync(name, "utf8"));
              }
            }
            // fallback m·∫∑c ƒë·ªãnh an to√†n
            return {
              site: { brand: "LightUnfold ‚Ä¢ Web3 AI X1000" },
              feeds: { top_n: 10, sources: ["coingecko_markets","coinlore_tickers"] }
            };
          }
          const cfg = readConfig();
          const topN = Number(cfg?.feeds?.top_n) || 10;

          // ------------------ ngu·ªìn d·ªØ li·ªáu ------------------
          const sources = {
            coingecko_markets: async () => {
              const url = "https://api.coingecko.com/api/v3/coins/markets"
                + "?vs_currency=usd&order=volume_desc&per_page=50&page=1"
                + "&price_change_percentage=1h,24h,7d";
              return await safeGet(url, { headers: { "x-cg-pro-api-key": "" } }); // ƒë·ªÉ tr·ªëng: public
            },
            coinlore_tickers: async () => {
              const j = await safeGet("https://api.coinlore.net/api/tickers/?start=0&limit=50");
              return j?.data || [];
            }
          };

          // ------------------ t√≠nh ƒëi·ªÉm ------------------
          const scoreCG = (c) =>
              (Number(c.price_change_percentage_1h_in_currency)||0)*0.40 +
              (Number(c.price_change_percentage_24h_in_currency)||0)*0.35 +
              (Number(c.price_change_percentage_7d_in_currency)||0)*0.25 +
              Math.log10((Number(c.total_volume)||1));

          const scoreCL = (c) => {
            const ch24 = Number(c.percent_change_24h)||0;
            const vol  = Number(c.volume24)||0;
            return ch24*0.70 + Math.log10(vol||1);
          };

          // ------------------ t·ªïng h·ª£p ------------------
          async function compose(){
            let items = [];
            const wanted = Array.isArray(cfg?.feeds?.sources) && cfg.feeds.sources.length
              ? cfg.feeds.sources
              : ["coingecko_markets"];

            for (const key of wanted) {
              try {
                const data = await (sources[key]?.());
                if (!data) continue;

                if (key === "coingecko_markets") {
                  items = items.concat(
                    data.map(c => ({
                      source: "coingecko",
                      id: c.id,
                      symbol: (c.symbol||"").toUpperCase(),
                      name: c.name,
                      price: Number(c.current_price)||0,
                      ch1h:  Number(c.price_change_percentage_1h_in_currency)||0,
                      ch24h: Number(c.price_change_percentage_24h_in_currency)||0,
                      ch7d:  Number(c.price_change_percentage_7d_in_currency)||0,
                      vol24h: Number(c.total_volume)||0,
                      score:  scoreCG(c),
                      link: `https://www.coingecko.com/en/coins/${c.id}`
                    }))
                  );
                }

                if (key === "coinlore_tickers") {
                  items = items.concat(
                    data.map(c => ({
                      source: "coinlore",
                      id: c.id,
                      symbol: (c.symbol||"").toUpperCase(),
                      name: c.name,
                      price: Number(c.price_usd)||0,
                      ch24h: Number(c.percent_change_24h)||0,
                      vol24h: Number(c.volume24)||0,
                      score:  scoreCL(c),
                      link: `https://www.coinlore.com/coin/${(c.name||"").toLowerCase().replace(/\s+/g,"-")}`
                    }))
                  );
                }
              } catch(e) {
                // ghi log nh·∫π nh√†ng, kh√¥ng l√†m h·ªèng to√†n job
                console.warn("source-error", key, String(e).slice(0,120));
              }
            }

            // g·ªôp theo symbol v√† l·∫•y b·∫£n c√≥ score cao nh·∫•t
            const best = {};
            for (const it of items) {
              if (!it.symbol) continue;
              const k = it.symbol;
              if (!best[k] || it.score > best[k].score) best[k] = it;
            }

            const out = Object.values(best)
              .sort((a,b)=> b.score - a.score)
              .slice(0, topN);

            const payload = {
              generated_at: new Date().toISOString(),
              brand: cfg?.site?.brand || "AI X1000",
              items: out
            };

            fs.mkdirSync("data", { recursive: true });
            fs.writeFileSync("data/latest.json", JSON.stringify(payload, null, 2));
            fs.writeFileSync("data/summary.txt",
              "üî• TOP: " + out.map(x => `${x.symbol}: $${x.price} (${(x.ch24h??0).toFixed(2)}%)`).join(" | ")
            );
          }

          // ch·∫°y
          await compose();
          NODE

      - name: Commit updated data
        run: |
          git config user.name  "ai-x1000-bot"
          git config user.email "ai-x1000-bot@users.noreply.github.com"
          git add data/latest.json data/summary.txt || true
          git commit -m "data: refresh $(date -u +'%Y-%m-%dT%H:%M:%SZ')" || echo "no changes"
          git push || true

      # --- Ph√°t s√≥ng (t√πy ch·ªçn: ch·ªâ ch·∫°y khi b·∫°n ƒë√£ ƒëi·ªÅn secrets) ---
      - name: Broadcast to Telegram (optional)
        if: ${{ secrets.TELEGRAM_BOT_TOKEN && secrets.TELEGRAM_CHAT_ID }}
        env:
          BOT:  ${{ secrets.TELEGRAM_BOT_TOKEN }}
          CHAT: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          MSG="$(cat data/summary.txt)"
          curl -s "https://api.telegram.org/bot${BOT}/sendMessage" \
               -d "chat_id=${CHAT}" -d "text=${MSG}" -d "disable_web_page_preview=true" >/dev/null || true

      - name: Broadcast to Discord (optional)
        if: ${{ secrets.DISCORD_WEBHOOK_URL }}
        env:
          WH: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          MSG="$(cat data/summary.txt | sed 's/"/\\"/g')"
          curl -s -H "Content-Type: application/json" -X POST \
               -d "{\"content\":\"${MSG}\"}" "$WH" >/dev/null || true

      - name: Broadcast to X/Twitter (optional)
        if: ${{ secrets.X_BEARER_TOKEN }}
        env:
          X_BEARER_TOKEN: ${{ secrets.X_BEARER_TOKEN }}
        run: |
          MSG="$(cat data/summary.txt | cut -c1-270)"
          curl -s -X POST "https://api.twitter.com/2/tweets" \
               -H "Authorization: Bearer ${X_BEARER_TOKEN}" \
               -H "Content-Type: application/json" \
               -d "{\"text\":\"${MSG}\"}" >/dev/null || true
