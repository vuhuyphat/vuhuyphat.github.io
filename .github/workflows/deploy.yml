name: Auto IPFS + ENS (no HTML change)

on:
  push:
    branches: [ main ]  # c·ª© push main l√† ch·∫°y (kh√¥ng c·∫ßn ch·∫°m HTML)

jobs:
  ipfs_and_ens:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install deps for inline script
        run: |
          npm init -y
          npm install @pinata/sdk ethers content-hash glob@10

      - name: Pin site to IPFS via Pinata (JWT) & update ENS
        env:
          PINATA_JWT: ${{ secrets.PINATA_JWT }}
          RPC_URL: ${{ secrets.RPC_URL }}
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
          ENS_NAME: ${{ secrets.ENS_NAME }}
        run: |
          node <<'NODE'
          const PinataClient = require('@pinata/sdk');
          const { glob } = require('glob');
          const fs = require('fs');
          const path = require('path');
          const contentHash = require('content-hash');
          const { ethers, namehash } = require('ethers');

          (async () => {
            // 1) Pin directory (ch·ªçn th∆∞ m·ª•c g·ªëc repo; b·∫°n c√≥ th·ªÉ ƒë·ªïi th√†nh ./dist n·∫øu d√πng build)
            const pinata = new PinataClient({ pinataJWTKey: process.env.PINATA_JWT });

            // Gom t·∫•t c·∫£ file tƒ©nh ƒë·ªÉ pin (b·ªè qua .git, node_modules, .github‚Ä¶)
            const files = await glob('**/*', {
              nodir: true,
              ignore: ['node_modules/**','**/.git/**','**/.github/**']
            });

            if (files.length === 0) {
              throw new Error('Kh√¥ng t√¨m th·∫•y file ƒë·ªÉ pin.');
            }

            // T·∫°o stream list cho SDK
            const streams = files.map((f) => ({
              path: f,
              content: fs.createReadStream(path.join(process.cwd(), f)),
            }));

            const pinRes = await pinata.pinFileToIPFS(streams, {
              pinataMetadata: { name: 'site-' + Date.now() },
            });

            const cid = pinRes.IpfsHash; // CID v1/v0 do Pinata tr·∫£ v·ªÅ
            console.log('‚úÖ Pinned to IPFS:', cid);

            // 2) Encode contenthash theo EIP-1577
            // ENS y√™u c·∫ßu CID v1 base32 ‚Üí contenthash d·∫°ng bytes
            const encoded = '0x' + contentHash.encode('ipfs-ns', cid);
            console.log('Contenthash (bytes):', encoded);

            // 3) Update ENS resolver.setContenthash
            const provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
            // PRIVATE_KEY kh√¥ng c√≥ '0x' ·ªü ƒë·∫ßu ‚Üí th√™m v√†o
            const pk = process.env.PRIVATE_KEY.startsWith('0x')
              ? process.env.PRIVATE_KEY
              : '0x' + process.env.PRIVATE_KEY;
            const wallet = new ethers.Wallet(pk, provider);

            const ENS_REGISTRY = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';
            const ensAbi = [
              'function resolver(bytes32 node) external view returns (address)'
            ];
            const registry = new ethers.Contract(ENS_REGISTRY, ensAbi, provider);

            const node = namehash(process.env.ENS_NAME);
            const resolverAddr = await registry.resolver(node);
            if (resolverAddr === ethers.ZeroAddress) {
              throw new Error('T√™n ENS ch∆∞a c√≥ resolver.');
            }

            const resolverAbi = [
              'function setContenthash(bytes32 node, bytes hash) external'
            ];
            const resolver = new ethers.Contract(resolverAddr, resolverAbi, wallet);

            const tx = await resolver.setContenthash(node, encoded);
            console.log('‚õΩ G·ª≠i giao d·ªãch setContenthash:', tx.hash);
            const rc = await tx.wait();
            console.log('üéâ ƒê√£ c·∫≠p nh·∫≠t ENS. Block:', rc.blockNumber);

            // In th√™m URL tham kh·∫£o
            console.log('‚û°Ô∏è  ENS (eth.limo): https://' + process.env.ENS_NAME + '.eth.limo/');
            console.log('‚û°Ô∏è  IPFS (gateway pinata): https://gateway.pinata.cloud/ipfs/' + cid + '/');
          })().catch((e) => {
            console.error('‚ùå L·ªói:', e);
            process.exit(1);
          });
          NODE
