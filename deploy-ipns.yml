name: UCAN Upload â†’ Auto-IPNS (One-Paste)

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]
    paths:
      - "site/**"
      - "index.html"
      - ".github/workflows/auto-ipns.yml"
  schedule:
    - cron: "0 */6 * * *"   # cháº¡y má»—i 6 giá»

permissions:
  contents: read

concurrency:
  group: ipns-publish
  cancel-in-progress: true

jobs:
  publish:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install deps (w3up + w3name)
        run: |
          mkdir -p .onepaste && cd .onepaste
          npm init -y >/dev/null
          npm i @web3-storage/w3up-client @ucanto/principal @web3-storage/w3name mime dotenv >/dev/null

      - name: Create uploader script (UCAN â†’ IPFS â†’ IPNS)
        run: |
          cat > .onepaste/upload_ipns.mjs <<'EOF'
          import 'dotenv/config'
          import fs from 'fs'
          import path from 'path'
          import mime from 'mime'
          import * as Client from '@web3-storage/w3up-client'
          import * as Principal from '@ucanto/principal/ed25519'
          import * as Name from '@web3-storage/w3name'

          const KEY_PATH = '.w3name.key'
          const exists = p => { try { fs.accessSync(p); return true } catch { return false } }

          async function collectFiles(inputPath){
            const stat = fs.statSync(inputPath)
            if (stat.isDirectory()){
              const files=[], root=inputPath
              ;(function walk(dir){
                for (const n of fs.readdirSync(dir)){
                  const p=path.join(dir,n), s=fs.statSync(p)
                  if (s.isDirectory()) walk(p)
                  else{
                    const rel=path.relative(root,p).split(path.sep).join('/')
                    const type=mime.getType(p)||'application/octet-stream'
                    files.push(new File([fs.readFileSync(p)], rel, { type }))
                  }
                }
              })(inputPath)
              if(!files.length) throw new Error('ThÆ° má»¥c trá»‘ng.')
              return {kind:'dir', files}
            } else {
              const name=path.basename(inputPath)
              const type=mime.getType(inputPath)||'application/octet-stream'
              return {kind:'file', files:[new File([fs.readFileSync(inputPath)], name, {type})]}
            }
          }

          async function uploadWithUCAN(src){
            const UCAN      = process.env.WEB3_STORAGE_UCAN || process.env.WEB3_STORAGE_KEY
            const SPACE_DID = process.env.WEB3_SPACE_DID    || process.env.WEB3_SPACE_KEY
            if(!UCAN||!SPACE_DID) throw new Error('Thiáº¿u UCAN hoáº·c SPACE_DID.')

            const principal = await Principal.generate()
            const client = await Client.create({ principal })
            const space = await client.addSpace(SPACE_DID)
            await client.setCurrentSpace(space.did())

            const proof = await Client.importDelegation(UCAN)
            await client.addProof(proof)

            const target = exists('site') ? 'site' : (process.env.UPLOAD_PATH || 'site')
            const src = exists(target) ? target : (exists('index.html') ? 'index.html' : target)
            const {kind, files}=await collectFiles(src)

            console.log('ðŸ“¦ Sáº½ upload:', kind==='dir' ? `${files.length} file trong ${src}` : src)

            let cid
            if(kind==='dir'){
              cid = await client.uploadDirectory(files, {
                onShardStored: ({cid}) => console.log('â€¢ stored shard:', cid.toString())
              })
            } else {
              cid = await client.uploadFile(files[0], {
                onShardStored: ({cid}) => console.log('â€¢ stored shard:', cid.toString())
              })
            }
            const c=cid.toString()
            console.log('\\nâœ… Upload xong  â†’ CID:', c)
            console.log('Gateway:', `https://w3s.link/ipfs/${c}/`)
            return c
          }

          async function loadOrCreateName(){
            const envKey=(process.env.W3NAME_KEY||'').trim()
            if(envKey){ console.log('ðŸ” DÃ¹ng W3NAME_KEY tá»« secrets.'); return await Name.from(Buffer.from(envKey,'base64')) }
            if(exists(KEY_PATH)){ console.log('ðŸ” DÃ¹ng khoÃ¡ IPNS Ä‘Ã£ lÆ°u.'); return await Name.from(Buffer.from(fs.readFileSync(KEY_PATH,'utf8').trim(),'base64')) }
            const name = await Name.create()
            const b64 = Buffer.from(name.key.bytes).toString('base64')
            fs.writeFileSync(KEY_PATH,b64)
            console.log('ðŸ†• Táº¡o IPNS name:', name.toString())
            console.log('âš ï¸ Láº§n Ä‘áº§u: khoÃ¡ Ä‘Æ°á»£c Ä‘Ã­nh kÃ¨m artifact .w3name.key â€“ nhá»› lÆ°u vÃ o secret W3NAME_KEY cho láº§n sau.')
            return name
          }

          async function publishIPNS(cid){
            const name = await loadOrCreateName()
            const value = `/ipfs/${cid}`
            let rev
            try { rev = await Name.increment(await Name.resolve(name), value) }
            catch { rev = await Name.v0(name, value) }
            await Name.publish(rev, name.key)
            const ipns = name.toString()
            console.log('\\nðŸ”— IPNS cáº­p nháº­t!')
            console.log('IPNS:', ipns)
            console.log('Gateway (IPNS):', `https://w3s.link/ipns/${ipns}`)
            fs.writeFileSync('ipns.txt', ipns)
            fs.writeFileSync('cid.txt', cid)
          }

          async function main(){
            const cid = await uploadWithUCAN(process.env.UPLOAD_PATH || 'site')
            await publishIPNS(cid)
          }
          main().catch(e=>{ console.error('\\nâŒ Lá»—i:', e?.message||e); process.exit(1) })
          EOF

      - name: Run â€¢ Upload + IPNS
        env:
          WEB3_STORAGE_UCAN: ${{ secrets.WEB3_STORAGE_UCAN || secrets.WEB3_STORAGE_KEY }}
          WEB3_SPACE_DID:   ${{ secrets.WEB3_SPACE_DID    || secrets.WEB3_SPACE_KEY   }}
          W3NAME_KEY:       ${{ secrets.W3NAME_KEY }}   # cÃ³ thÃ¬ dÃ¡n; trá»‘ng thÃ¬ run Ä‘áº§u sáº½ táº¡o
          UPLOAD_PATH:      site                        # Ä‘á»•i sang dist/public náº¿u cáº§n
        run: node .onepaste/upload_ipns.mjs

      - name: Upload artifacts â€¢ IPNS/CID (+ key náº¿u vá»«a táº¡o)
        uses: actions/upload-artifact@v4
        with:
          name: ipns-publish-output
          path: |
            ipns.txt
            cid.txt
            .w3name.key
          if-no-files-found: ignore

      - name: Pin CID to Pinata (optional)
        if: always()
        env:
          PINATA_JWT: ${{ secrets.PINATA_JWT }}
        run: |
          if [ -f cid.txt ] && [ -n "$PINATA_JWT" ]; then
            CID="$(cat cid.txt)"
            echo "Pinning CID to Pinata: $CID"
            curl -s -X POST "https://api.pinata.cloud/pinning/pinByHash" \
              -H "Authorization: Bearer $PINATA_JWT" \
              -H "Content-Type: application/json" \
              --data "{\"hashToPin\":\"$CID\",\"pinataMetadata\":{\"name\":\"onepaste-auto-ipns\"}}"
            echo " â†’ Done"
          else
            echo "Skip Pinata pin (missing cid.txt or PINATA_JWT)"
          fi

      - name: Quick verify gateways
        run: |
          CID=$(cat cid.txt 2>/dev/null || true)
          IPNS=$(cat ipns.txt 2>/dev/null || true)
          echo "CID=$CID"
          echo "IPNS=$IPNS"
          echo "Try: https://w3s.link/ipfs/${CID}/"
          echo "Try: https://ipfs.io/ipns/${IPNS}?t=$(date +%s)"
          echo "Try: https://cloudflare-ipfs.com/ipns/${IPNS}?t=$(date +%s)"

      - name: Summary
        run: |
          echo "### Káº¿t quáº£ IPNS" >> $GITHUB_STEP_SUMMARY
          test -f cid.txt  && echo "- **CID:** \`$(cat cid.txt)\`"   >> $GITHUB_STEP_SUMMARY || true
          test -f ipns.txt && echo "- **IPNS:** \`$(cat ipns.txt)\`" >> $GITHUB_STEP_SUMMARY || true
          test -f ipns.txt && echo "- **Gateway:** https://w3s.link/ipns/$(cat ipns.txt)" >> $GITHUB_STEP_SUMMARY || true
