name: Pages + Web3 (Auto-IPNS, One-Source)

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]
    paths:
      - "site/**"
      - "index.html"
      - ".github/workflows/pages+ipns.yml"

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: pages-ipns-sync
  cancel-in-progress: true

env:
  SOURCE_DIR: site   # đổi nếu bạn muốn

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Chuẩn hoá thư mục nguồn để Pages & IPNS dùng cùng 1 chỗ
      - name: Prepare source folder
        run: |
          if [ -d "$SOURCE_DIR" ]; then
            echo "Using folder: $SOURCE_DIR"
          elif [ -f "index.html" ]; then
            echo "No $SOURCE_DIR; using root index.html"
            mkdir -p "$SOURCE_DIR"
            cp -a index.html "$SOURCE_DIR/"
          else
            echo "No site/ or index.html found → create minimal page"
            mkdir -p "$SOURCE_DIR"
            echo '<!doctype html><meta charset=utf-8><title>One-Paste</title><h1>Hello Pages + IPNS</h1>' > "$SOURCE_DIR/index.html"
          fi
          ls -la "$SOURCE_DIR"

      # ====== Triển khai Web2 (GitHub Pages) từ cùng thư mục ======
      - name: Upload artifact for Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: ${{ env.SOURCE_DIR }}

      - name: Deploy to GitHub Pages
        id: pages
        uses: actions/deploy-pages@v4

      # ====== Web3: Upload UCAN + cập nhật IPNS từ cùng thư mục ======
      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install deps (w3up + w3name)
        run: |
          mkdir -p .onepaste && cd .onepaste
          npm init -y >/dev/null
          npm i @web3-storage/w3up-client @ucanto/principal @web3-storage/w3name mime dotenv >/dev/null

      - name: Create uploader script
        run: |
          cat > .onepaste/upload_ipns.mjs <<'EOF'
          import 'dotenv/config'
          import fs from 'fs'
          import path from 'path'
          import mime from 'mime'
          import * as Client from '@web3-storage/w3up-client'
          import * as Principal from '@ucanto/principal/ed25519'
          import * as Name from '@web3-storage/w3name'
          const exists=p=>{try{fs.accessSync(p);return true}catch{return false}}
          const KEY_PATH='.w3name.key'

          async function collect(dir){
            const st=fs.statSync(dir)
            if(st.isDirectory()){
              const files=[], root=dir
              ;(function walk(d){
                for(const n of fs.readdirSync(d)){
                  const p=path.join(d,n), s=fs.statSync(p)
                  if(s.isDirectory()) walk(p)
                  else{
                    const rel=path.relative(root,p).split(path.sep).join('/')
                    const type=mime.getType(p)||'application/octet-stream'
                    files.push(new File([fs.readFileSync(p)], rel, {type}))
                  }
                }
              })(dir)
              if(!files.length) throw new Error('Empty folder')
              return {kind:'dir', files}
            }else{
              const name=path.basename(dir)
              const type=mime.getType(dir)||'application/octet-stream'
              return {kind:'file', files:[new File([fs.readFileSync(dir)], name, {type})]}
            }
          }

          async function upload(src){
            const UCAN=process.env.WEB3_STORAGE_UCAN||process.env.WEB3_STORAGE_KEY
            const SPACE=process.env.WEB3_SPACE_DID||process.env.WEB3_SPACE_KEY
            if(!UCAN||!SPACE) throw new Error('Missing UCAN or SPACE_DID')

            const principal=await Principal.generate()
            const client=await Client.create({principal})
            const space=await client.addSpace(SPACE); await client.setCurrentSpace(space.did())
            const proof=await Client.importDelegation(UCAN); await client.addProof(proof)

            const {kind,files}=await collect(src)
            let cid
            if(kind==='dir') cid=await client.uploadDirectory(files,{onShardStored:({cid})=>console.log('• shard',cid.toString())})
            else cid=await client.uploadFile(files[0],{onShardStored:({cid})=>console.log('• shard',cid.toString())})
            const c=cid.toString()
            console.log('CID:',c,'\nGateway: https://w3s.link/ipfs/'+c+'/')
            return c
          }

          async function getName(){
            const env=(process.env.W3NAME_KEY||'').trim()
            if(env) return await Name.from(Buffer.from(env,'base64'))
            if(exists(KEY_PATH)) return await Name.from(Buffer.from(fs.readFileSync(KEY_PATH,'utf8').trim(),'base64'))
            const name=await Name.create()
            fs.writeFileSync(KEY_PATH,Buffer.from(name.key.bytes).toString('base64'))
            console.log('Created IPNS name:', name.toString())
            return name
          }

          async function publish(cid){
            const name=await getName()
            const val='/ipfs/'+cid
            let rev
            try{ rev=await Name.increment(await Name.resolve(name), val) }
            catch{ rev=await Name.v0(name, val) }
            await Name.publish(rev, name.key)
            const ipns=name.toString()
            fs.writeFileSync('cid.txt',cid)
            fs.writeFileSync('ipns.txt',ipns)
            console.log('IPNS:',ipns,'\nIPNS gw: https://w3s.link/ipns/'+ipns)
          }

          const SRC=process.env.SRC||'site'
          const real = exists(SRC)?SRC:(exists('index.html')?'index.html':SRC)
          upload(real).then(publish).catch(e=>{console.error('ERR',e?.message||e);process.exit(1)})
          EOF

      - name: Upload + IPNS (same folder used for Pages)
        env:
          WEB3_STORAGE_UCAN: ${{ secrets.WEB3_STORAGE_UCAN || secrets.WEB3_STORAGE_KEY }}
          WEB3_SPACE_DID:   ${{ secrets.WEB3_SPACE_DID    || secrets.WEB3_SPACE_KEY   }}
          W3NAME_KEY:       ${{ secrets.W3NAME_KEY }}
          SRC:              ${{ env.SOURCE_DIR }}
        run: node .onepaste/upload_ipns.mjs

      - name: Artifacts (cid/ipns + key nếu vừa tạo)
        uses: actions/upload-artifact@v4
        with:
          name: web3-ipns-output
          path: |
            cid.txt
            ipns.txt
            .w3name.key
          if-no-files-found: ignore

      - name: Pin CID to Pinata (optional)
        if: always()
        env:
          PINATA_JWT: ${{ secrets.PINATA_JWT }}
        run: |
          if [ -f cid.txt ] && [ -n "$PINATA_JWT" ]; then
            CID="$(cat cid.txt)"
            echo "Pin CID to Pinata: $CID"
            curl -s -X POST "https://api.pinata.cloud/pinning/pinByHash" \
              -H "Authorization: Bearer $PINATA_JWT" \
              -H "Content-Type: application/json" \
              --data "{\"hashToPin\":\"$CID\",\"pinataMetadata\":{\"name\":\"pages+ipns\"}}"
          else
            echo "Skip Pinata (no token or cid)"
          fi

      - name: Quick verify (3 gateways)
        run: |
          CID=$(cat cid.txt); IPNS=$(cat ipns.txt)
          echo "CID:  $CID"
          echo "IPNS: $IPNS"
          echo "IPFS  → https://w3s.link/ipfs/${CID}/"
          echo "IPNS  → https://w3s.link/ipns/${IPNS}?t=$(date +%s)"
          echo "      → https://ipfs.io/ipns/${IPNS}?t=$(date +%s)"
          echo "      → https://cloudflare-ipfs.com/ipns/${IPNS}?t=$(date +%s)"

      - name: Summary
        run: |
          echo "### Đồng bộ Web2 ↔ Web3 (1 nguồn)" >> $GITHUB_STEP_SUMMARY
          test -f cid.txt  && echo "- **CID:** \`$(cat cid.txt)\`" >> $GITHUB_STEP_SUMMARY
          test -f ipns.txt && echo "- **IPNS:** \`$(cat ipns.txt)\`" >> $GITHUB_STEP_SUMMARY
          test -f ipns.txt && echo "- **Open:** https://w3s.link/ipns/$(cat ipns.txt)" >> $GITHUB_STEP_SUMMARY
