name: ai-omnibot-v17.2-zerocost-ultra-payments-plus

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      mode:
        description: "Run mode"
        type: choice
        default: zerocost-ultra-payments-plus
        options: [zerocost-ultra-payments-plus]
      rss_urls:
        description: "CSV RSS URLs (override)"
        required: false
      seed_urls:
        description: "CSV seed websites to discover RSS (override)"
        required: false
      confidence_threshold:
        description: "AI score threshold 0..1 for LIVE actions"
        default: "0.999999"
  schedule:
    - cron: "*/1 * * * *"  # Run every 1 second

permissions:
  contents: write
  issues: write
  pull-requests: write
  models: read
  actions: write

concurrency:
  group: ai-omnibot-v17.2-zerocost-ultra-payments-plus-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: false

jobs:
  self-healing:
    runs-on: ubuntu-latest
    steps:
      - name: AI-Driven Self-Healing
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MONITORING_ENDPOINT: ${{ vars.MONITORING_ENDPOINT || 'https://api.x.ai/v1/monitor' }}
          LLM_API_URL: ${{ vars.LLM_API_URL || 'https://api.x.ai/v1/chat/completions' }}
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          LLAMA_API_URL: ${{ vars.LLAMA_API_URL || 'https://api.huggingface.co/models/llama-3.1' }}
          LLAMA_API_KEY: ${{ secrets.LLAMA_API_KEY }}
        run: |
          node --input-type=module - <<'NODE'
          import fetch from 'node-fetch'
          async function selfHeal() {
            const services = [
              'https://api.infura.io/v3/health', 'https://api.alchemy.com/health', 'https://ipfs.io/health',
              'https://arweave.net/health', 'https://rpc.hedera.com/health', 'https://rpc.mainnet.sui.io/health',
              'https://rpc.mainnet.berachain.com/health', 'https://rpc.mainnet.celestia.org/health',
              'https://rpc.mainnet.dymension.io/health', 'https://api.sumsub.com/health',
              'https://api.world-check.com/health', 'https://api.openlaw.io/health', 'https://api.corda.net/health',
              'https://prometheus.io/health', 'https://grafana.com/health', 'https://swarm.network/health',
              'https://siasky.net/health', 'https://hyperledger.org/health', 'https://api.poof.io/health',
              'https://api.cryptomus.com/health', 'https://api.nowpayments.io/health', 'https://api.alchemypay.com/health',
              'https://rpc.nervos.org/health', 'https://rpc.moonbeam.network/health'
            ]
            for (const url of services) {
              for (let i = 0; i < 10000000; i++) {
                try {
                  const res = await fetch(url, { timeout: 1000 })
                  if (res.ok) break
                  const prompt = `Service ${url} is down. Suggest fix in JSON: { fix: string }`
                  const fixRes = await fetch(process.env.LLM_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${process.env.LLM_API_KEY}` },
                    body: JSON.stringify({ model: 'grok-3', messages: [{ role: 'user', content: prompt }] })
                  })
                  const { choices } = await fixRes.json()
                  const fix = JSON.parse(choices[0].message.content).fix
                  console.log(`Applying fix for ${url}: ${fix}`)
                  await fetch(process.env.MONITORING_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ service: url, status: 'down', fix })
                  })
                } catch (e) {
                  console.log(`Self-healing retry ${i+1}/10000000 for ${url}:`, e.message)
                  await new Promise(r => setTimeout(r, 500))
                }
              }
            }
          }
          selfHeal()
          NODE

  initialize:
    runs-on: ubuntu-latest
    needs: self-healing
    steps:
      - name: Zero-Cost Environment Setup with Payment Wallets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          KILL_SWITCH: ${{ secrets.KILL_SWITCH }}
          DID_SEED: ${{ secrets.DID_SEED }}
          MOMO_WALLET: ${{ secrets.MOMO_WALLET || '0567892030' }}
          VIETCOMBANK_WALLET: ${{ secrets.VIETCOMBANK_WALLET || '9567892030' }}
          PAYPAL_WALLET: ${{ secrets.PAYPAL_WALLET || 'vumumabada@gmail.com' }}
          USDT_ADDRESS: ${{ secrets.USDT_ADDRESS || '0x5da80d0f7e2df3cb0aa73d6a942bbe36b046b8f0' }}
          ETH_ADDRESS: ${{ secrets.ETH_ADDRESS || '0x54E15A7b6d4213beE87800432A151d794638E3C2' }}
        run: |
          echo "## Initializing Zero-Cost Ultra Payments Plus" >> $GITHUB_STEP_SUMMARY
          if [ -z "$KILL_SWITCH" ]; then
            curl -s -X PUT \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -d '{"encrypted_value":"T05F"}' \
              "https://api.github.com/repos/${{ github.repository }}/actions/secrets/KILL_SWITCH"
            echo "Set KILL_SWITCH=ON" >> $GITHUB_STEP_SUMMARY
          fi
          node --input-type=module - <<'NODE'
          import fetch from 'node-fetch'
          import { create3ID } from '@ceramicnetwork/3id-did'
          async function registerFreeServices() {
            const services = [
              { name: 'Infura', url: 'https://infura.io/register', keys: ['INFURA_API_KEY'] },
              { name: 'Alchemy', url: 'https://alchemy.com/register', keys: ['ALCHEMY_API_KEY'] },
              { name: 'IPFS', url: 'https://ipfs.io/register', keys: ['IPFS_API_KEY'] },
              { name: 'Arweave', url: 'https://arweave.net/register', keys: ['ARWEAVE_KEY'] },
              { name: 'Hedera', url: 'https://hedera.com/register', keys: ['HEDERA_API_KEY'] },
              { name: 'Sui', url: 'https://sui.io/register', keys: ['SUI_API_KEY'] },
              { name: 'Berachain', url: 'https://berachain.com/register', keys: ['BERACHAIN_API_KEY'] },
              { name: 'Celestia', url: 'https://celestia.org/register', keys: ['CELESTIA_API_KEY'] },
              { name: 'Dymension', url: 'https://dymension.io/register', keys: ['DYMENSION_API_KEY'] },
              { name: 'Nervos', url: 'https://nervos.org/register', keys: ['NERVOS_API_KEY'] },
              { name: 'Moonbeam', url: 'https://moonbeam.network/register', keys: ['MOONBEAM_API_KEY'] },
              { name: 'SumSub', url: 'https://api.sumsub.com/register', keys: ['SUMSUB_API_KEY'] },
              { name: 'WorldCheck', url: 'https://api.world-check.com/register', keys: ['WORLDCHECK_API_KEY'] },
              { name: 'OpenLaw', url: 'https://api.openlaw.io/register', keys: ['OPENLAW_API_KEY'] },
              { name: 'Corda', url: 'https://api.corda.net/register', keys: ['CORDA_API_KEY'] },
              { name: 'uPort', url: 'https://uport.me/register', keys: ['UPORT_API_KEY'] },
              { name: 'Civic', url: 'https://civic.com/register', keys: ['CIVIC_API_KEY'] },
              { name: 'Poof', url: 'https://api.poof.io/register', keys: ['POOF_API_KEY'] },
              { name: 'Cryptomus', url: 'https://api.cryptomus.com/register', keys: ['CRYPTOMUS_API_KEY'] },
              { name: 'NOWPayments', url: 'https://api.nowpayments.io/register', keys: ['NOWPAYMENTS_API_KEY'] },
              { name: 'AlchemyPay', url: 'https://api.alchemypay.com/register', keys: ['ALCHEMYPAY_API_KEY'] },
              { name: 'MoonPay', url: 'https://api.moonpay.com/register', keys: ['MOONPAY_API_KEY'] }
            ]
            for (const { name, url, keys } of services) {
              for (let i = 0; i < 10000000; i++) {
                try {
                  const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: `temp-${Date.now()}-${i}@${name.toLowerCase()}.com`, password: 'ZeroCostUltra123!' })
                  })
                  const data = await res.json()
                  for (const key of keys) {
                    const val = data[key.split('_')[0].toLowerCase()] || data.apiKey || data.key
                    if (val) {
                      await fetch(`https://api.github.com/repos/${{ github.repository }}/actions/secrets/${key}_${i}`, {
                        method: 'PUT',
                        headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                        body: JSON.stringify({ encrypted_value: val })
                      })
                      console.log(`Registered ${name} ${key}_${i}`)
                    }
                  }
                  break
                } catch (e) { console.log(`${name} registration retry ${i+1}/10000000:`, e.message); await new Promise(r => setTimeout(r, 500)) }
              }
            }
            // Generate 2,000,000 wallets per blockchain
            const blockchains = [
              'BNB Chain', 'Ethereum', 'Polygon', 'Solana', 'Arbitrum', 'Optimism', 'Hedera', 'Sui', 'Berachain',
              'Celestia', 'Dymension', 'Nervos', 'Moonbeam', 'Cardano', 'Polkadot', 'Aptos', 'Near', 'Cosmos',
              'Starknet', 'ZkSync', 'Flow', 'Tezos', 'Algorand', 'Ton', 'Base', 'Linea', 'Mantle', 'Scroll', 'Sei',
              'Cronos', 'Monad', 'Fuel', 'Eclipse'
            ]
            const Web3 = (await import('web3')).default
            const web3 = new Web3()
            for (const chain of blockchains) {
              for (let i = 0; i < 2000000; i++) {
                const account = web3.eth.accounts.create()
                await fetch(`https://api.github.com/repos/${{ github.repository }}/actions/secrets/TEMP_WALLET_PRIVATE_KEY_${chain}_${i}`, {
                  method: 'PUT',
                  headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                  body: JSON.stringify({ encrypted_value: account.privateKey })
                })
                await fetch(`https://api.github.com/repos/${{ github.repository }}/actions/secrets/TEMP_WALLET_ADDRESS_${chain}_${i}`, {
                  method: 'PUT',
                  headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                  body: JSON.stringify({ encrypted_value: account.address })
                })
                console.log(`Generated wallet ${chain}_${i}:`, account.address)
              }
            }
            // Bootstrap capital from faucets
            const faucets = [
              'https://testnet.bnbchain.org/faucet', 'https://faucet.hedera.com', 'https://faucet.sui.io',
              'https://faucet.berachain.com', 'https://faucet.celestia.org', 'https://faucet.dymension.io',
              'https://faucet.nervos.org', 'https://faucet.moonbeam.network', 'https://faucet.polygon.technology',
              'https://faucet.solana.com', 'https://faucet.arbitrum.io', 'https://faucet.optimism.io',
              'https://faucet.cardano.org', 'https://faucet.polkadot.io', 'https://faucet.aptoslabs.com',
              'https://faucet.near.org', 'https://faucet.cosmos.network', 'https://faucet.starknet.io',
              'https://faucet.zksync.io', 'https://faucet.flow.com', 'https://faucet.tezos.com',
              'https://faucet.algorand.org', 'https://faucet.ton.org', 'https://faucet.base.org',
              'https://faucet.linea.build', 'https://faucet.mantle.xyz', 'https://faucet.scroll.io',
              'https://faucet.sei.io', 'https://faucet.cronos.org', 'https://faucet.monad.xyz',
              'https://faucet.fuel.network', 'https://faucet.eclipse.xyz', 'https://faucet.starknet-faucet.com',
              'https://faucet.zksync-faucet.com', 'https://faucet.celestia-testnet.com',
              'https://faucet.dymension-testnet.com'
            ]
            for (const faucet of faucets) {
              for (let i = 0; i < 2000000; i++) {
                try {
                  await fetch(faucet, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: process.env[`TEMP_WALLET_ADDRESS_${faucet.split('.')[1].toUpperCase()}_${i}`] })
                  })
                  console.log(`Requested faucet from ${faucet} for wallet ${i}`)
                } catch (e) { console.log(`Faucet error ${faucet} wallet ${i}:`, e.message) }
              }
            }
            // Initialize Binance Web3 Wallet and Cryptnox Card
            await fetch('https://api.binance.com/web3/wallet/register', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ wallet: process.env.ETH_ADDRESS })
            })
            await fetch('https://api.cryptnox.com/card/register', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ wallet: process.env.ETH_ADDRESS })
            })
            // Initialize ENS and HNS domains
            const domains = ['infinitybot.eth', 'infinitybot.hns']
            for (const domain of domains) {
              await fetch('https://arweave.net/tx', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: JSON.stringify({ domain }), tags: [{ name: 'ZeroCostUltra', value: 'v17.2' }, { name: 'Domain', value: domain }] })
              })
            }
            // Initialize DID for KYC/AML
            const ceramic = await create3ID({ seed: process.env.DID_SEED })
            await ceramic.authenticate()
            console.log('Initialized DID:', ceramic.id)
            // Register payment wallets
            const paymentWallets = [
              { type: 'MoMo', id: process.env.MOMO_WALLET, api: 'https://api.nowpayments.io/link' },
              { type: 'Vietcombank', id: process.env.VIETCOMBANK_WALLET, api: 'https://api.alchemypay.com/link' },
              { type: 'PayPal', id: process.env.PAYPAL_WALLET, api: 'https://api.cryptomus.com/link' },
              { type: 'USDT', id: process.env.USDT_ADDRESS, api: 'https://api.moonpay.com/link' },
              { type: 'ETH', id: process.env.ETH_ADDRESS, api: 'https://api.binance.com/web3/wallet/link' }
            ]
            for (const wallet of paymentWallets) {
              await fetch(wallet.api, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ wallet: wallet.id, type: wallet.type })
              })
              console.log(`Linked ${wallet.type} wallet: ${wallet.id}`)
            }
          }
          registerFreeServices()
          NODE

  core-agent:
    runs-on: ubuntu-latest
    needs: initialize
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - name: Install WASM Dependencies
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq wasm-pack
          npm i rss-parser@3 node-fetch@3 cheerio@1 qrcode@1 web3@1 @ceramicnetwork/3id-did@1 nostr-tools@1 @uport/uport-js@1 @civic/civic-js@1 @sumsub/sumsub-js@1 @openlaw/openlaw-js@1 @corda/corda-js@1 prometheus-client@1 grafana-sdk@1 swarm-js@1 siasky-js@1 hyperledger-fabric-sdk@1 @binance/web3-wallet@1 cryptnox-card@1 @moonpay/moonpay-js@1
      - name: Deploy Smart Contract
        env:
          TEMP_WALLET_PRIVATE_KEY_BNBCHAIN_0: ${{ secrets.TEMP_WALLET_PRIVATE_KEY_BNBCHAIN_0 }}
          ETH_ADDRESS: ${{ secrets.ETH_ADDRESS || '0x54E15A7b6d4213beE87800432A151d794638E3C2' }}
        run: |
          node --input-type=module - <<'NODE'
          import Web3 from 'web3'
          import fs from 'fs'
          const blockchains = [
            { name: 'BNB Chain', rpc: 'https://bsc-dataseed.binance.org', stake: '0xPancakeSwap', zkr: false },
            { name: 'Ethereum', rpc: 'https://mainnet.infura.io/v3/${{ secrets.INFURA_API_KEY_0 }}', stake: '0xUniswapV4', zkr: false },
            { name: 'Polygon', rpc: 'https://rpc-mainnet.maticvigil.com', stake: '0xAavePolygonContract', zkr: false },
            { name: 'Solana', rpc: 'https://api.mainnet-beta.solana.com', stake: '0xSolanaProgram', zkr: false },
            { name: 'Nervos', rpc: 'https://rpc.nervos.org', stake: '0xNervosStake', zkr: false },
            { name: 'Moonbeam', rpc: 'https://rpc.moonbeam.network', stake: '0xMoonbeamStake', zkr: false }
          ]
          const contractABI = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"donor","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"string","name":"currency","type":"string"}],"name":"Donated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"NFTMinted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"subscriber","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"string","name":"currency","type":"string"}],"name":"Subscribed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"player","type":"address"},{"indexed":false,"internalType":"uint256","name":"reward","type":"uint256"}],"name":"GameReward","type":"event"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"currency","type":"string"}],"name":"donate","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"mintNFT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"player","type":"address"},{"internalType":"uint256","name":"reward","type":"uint256"}],"name":"rewardGame","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"currency","type":"string"}],"name":"subscribe","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"subscribers","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalDonations","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSubscriptions","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}]
          const contractBytecode = "0x608060405234801561001057600080fd5b506102c3806100206000396000f3fe60806040526004361061004e5760003560e01c80633ccfd60b146100575780638da5cb5b1461006e578063a6f9dae11461009f578063d0e30db0146100bf578063f10fdf5c146100d7578063f2b1b8821461010a57610055565b3661005557005b600080fd5b34801561006357600080fd5b5061006c61012a565b005b34801561007a57600080fd5b50600054610087906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b3480156100ab57600080fd5b5061006c6100ba36600461024c565b61013e565b6100d56100d536600461026e565b61015e565b005b3480156100e357600080fd5b506100f76100f2366004610290565b6101b0565b60405190815260200160405180910390f35b34801561011657600080fd5b5061012060015481565b6040519081526020016100f7565b6000546001600160a01b0316331461013d57600080fd5b005b6000546001600160a01b0316331461015557600080fd5b61013d6101e8565b6040516323b872dd60e01b81523360048201523060248201526044820181905260009081906064906000856001600160a01b03168663a9059cbb60e01b9060840160408051601f198184030181529181526020820180516001600160e01b031663a9059cbb60e01b1790528151600094859450909250871692506101e49150829060240190565b60405180910390a150565b6000805460405160016000160a01b0390911690600081818185875af1925050503d8060008114610237576040519150601f19603f3d011682016040523d82523d6000602084013e61023c565b606091505b50509050565b60006020828403121561025e57600080fd5b81356001600160a01b03169050919050565b6000806040838503121561028157600080fd5b50508035936020909101359150565b6000602082840312156102a257600080fd5b503591905056"
          async function deployContract() {
            for (const chain of blockchains) {
              for (let i = 0; i < 2000000; i++) {
                try {
                  const web3 = new Web3(chain.rpc)
                  const account = web3.eth.accounts.privateKeyToAccount(process.env[`TEMP_WALLET_PRIVATE_KEY_${chain}_${i}`] || process.env.TEMP_WALLET_PRIVATE_KEY_BNBCHAIN_0)
                  web3.eth.accounts.wallet.add(account)
                  const contract = new web3.eth.Contract(contractABI)
                  const deployTx = contract.deploy({ data: contractBytecode })
                  const gas = await deployTx.estimateGas({ from: account.address })
                  const tx = await deployTx.send({ from: account.address, gas })
                  fs.appendFileSync('contract-addresses.txt', `${chain.name}_${i}: ${tx.options.address}\n`)
                  console.log(`Contract deployed on ${chain.name}_${i}:`, tx.options.address)
                  // Send initial funds to main ETH wallet
                  if (chain.name === 'Ethereum') {
                    await web3.eth.sendTransaction({
                      from: account.address,
                      to: process.env.ETH_ADDRESS,
                      value: web3.utils.toWei('0.0001', 'ether')
                    })
                    console.log(`Sent 0.0001 ETH to ${process.env.ETH_ADDRESS}`)
                  }
                  break
                } catch (e) { console.error(`Contract deploy error on ${chain.name}_${i}:`, e.message); await new Promise(r => setTimeout(r, 500)) }
              }
            }
          }
          deployContract()
          NODE
      - name: AI Viral Campaigns with BNB and AlgosOne Referrals
        env:
          LLM_API_URL: ${{ vars.LLM_API_URL || 'https://api.x.ai/v1/chat/completions' }}
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          LLAMA_API_URL: ${{ vars.LLAMA_API_URL || 'https://api.huggingface.co/models/llama-3.1' }}
          LLAMA_API_KEY: ${{ secrets.LLAMA_API_KEY }}
          TIKTOK_API_KEY: ${{ secrets.TIKTOK_API_KEY }}
          INSTAGRAM_API_KEY: ${{ secrets.INSTAGRAM_API_KEY }}
          YOUTUBE_API_KEY: ${{ secrets.YOUTUBE_API_KEY }}
          REDDIT_API_KEY: ${{ secrets.REDDIT_API_KEY }}
          WECHAT_API_KEY: ${{ secrets.WECHAT_API_KEY }}
          KAKAOTALK_API_KEY: ${{ secrets.KAKAOTALK_API_KEY }}
          BINANCE_REFERRAL_LINK: ${{ secrets.BINANCE_REFERRAL_LINK || 'https://www.binance.com/referral/earn-together/refer-in-hotsummer/claim?hl=vi&ref=GRO_20338_9V44N' }}
          ALGOSONE_REFERRAL_LINK: ${{ secrets.ALGOSONE_REFERRAL_LINK || 'https://algosone.page.link/MbtR' }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import fetch from 'node-fetch'
          async function viralCampaign() {
            const keywords = fs.existsSync('data/keywords.json') ? JSON.parse(fs.readFileSync('data/keywords.json', 'utf8')) : {
              'airdrop': 0.999999, 'nft': 0.999999, 'defi': 0.999999, 'staking': 0.999999, 'web3 gaming': 0.999998,
              'socialfi': 0.999998, 'prediction market': 0.999998, 'rwa': 0.999998, 'yield farming': 0.999998,
              'uniswap': 0.999997, 'aave': 0.999997, 'polymarket': 0.999997, 'goldfinch': 0.999997, 'realt': 0.999997,
              'lens': 0.999996, 'cyberconnect': 0.999996, 'star atlas': 0.999996, 'the sandbox': 0.999996,
              'decentraland': 0.999996, 'bnb': 0.999999, 'algosone': 0.999999, 'ai wallet': 0.999999,
              'crypto profits': 0.999999, 'tiền điện tử': 0.999999, 'đầu tư': 0.999999, 'crypto': 0.999999,
              'trading': 0.999999, '区块链': 0.999999, '交易': 0.999999, '区块链钱包': 0.999999, 'ví thông minh': 0.999999
            }
            const prompt = `Generate viral Web3 video/meme for ${Object.keys(keywords).slice(0, 25).join(', ')}. Include Binance referral link (${process.env.BINANCE_REFERRAL_LINK}) and AlgosOne referral link (${process.env.ALGOSONE_REFERRAL_LINK}). Optimize for TikTok, Instagram, YouTube, X, Telegram, Reddit, WeChat, KakaoTalk with sentiment analysis for 4% click-through rate. Use AlgosOne AI wallet messaging: "Grow your crypto with AI-powered AlgosOne wallet!" Return JSON: { content: string, video_url: string }`
            const res = await fetch(process.env.LLAMA_API_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${process.env.LLAMA_API_KEY}` },
              body: JSON.stringify({
                model: 'llama-3.1',
                prompt: prompt,
                max_tokens: 512
              })
            })
            const { choices } = await res.json()
            const { content, video_url } = JSON.parse(choices[0].text)
            const platforms = [
              { name: 'TikTok', url: 'https://api.tiktok.com/v2/post', key: process.env.TIKTOK_API_KEY, body: { video: video_url, description: `${content} Join Binance: ${process.env.BINANCE_REFERRAL_LINK} | AlgosOne: ${process.env.ALGOSONE_REFERRAL_LINK}` } },
              { name: 'Instagram', url: 'https://api.instagram.com/v1/media', key: process.env.INSTAGRAM_API_KEY, body: { video: video_url, caption: `${content} Join Binance: ${process.env.BINANCE_REFERRAL_LINK} | AlgosOne: ${process.env.ALGOSONE_REFERRAL_LINK}` } },
              { name: 'YouTube', url: 'https://www.googleapis.com/youtube/v3/videos', key: process.env.YOUTUBE_API_KEY, body: { snippet: { title: 'ZeroCostUltra', description: `${content} Join Binance: ${process.env.BINANCE_REFERRAL_LINK} | AlgosOne: ${process.env.ALGOSONE_REFERRAL_LINK}` }, contentDetails: { video: video_url } } },
              { name: 'X', url: 'https://api.x.com/v2/tweets', key: process.env.LLM_API_KEY, body: { text: `${content} Join Binance: ${process.env.BINANCE_REFERRAL_LINK} | AlgosOne: ${process.env.ALGOSONE_REFERRAL_LINK}` } },
              { name: 'Telegram', url: `https://api.telegram.org/bot${process.env.TELEGRAM_API_KEY}/sendVideo`, key: process.env.TELEGRAM_API_KEY, body: { chat_id: '@ZeroCostUltra', video: video_url, caption: `${content} Join Binance: ${process.env.BINANCE_REFERRAL_LINK} | AlgosOne: ${process.env.ALGOSONE_REFERRAL_LINK}` } },
              { name: 'Reddit', url: 'https://api.reddit.com/api/submit', key: process.env.REDDIT_API_KEY, body: { sr: 'r/cryptocurrency', title: 'Grow with AlgosOne AI Wallet', text: `${content} Join Binance: ${process.env.BINANCE_REFERRAL_LINK} | AlgosOne: ${process.env.ALGOSONE_REFERRAL_LINK}` } },
              { name: 'WeChat', url: 'https://api.wechat.com/cgi-bin/message/custom/send', key: process.env.WECHAT_API_KEY, body: { touser: '@all', msgtype: 'video', video: { media_id: video_url, description: `${content} Join Binance: ${process.env.BINANCE_REFERRAL_LINK} | AlgosOne: ${process.env.ALGOSONE_REFERRAL_LINK}` } } },
              { name: 'KakaoTalk', url: 'https://api.kakaotalk.com/v2/message/send', key: process.env.KAKAOTALK_API_KEY, body: { template_object: { object_type: 'text', text: `${content} Join Binance: ${process.env.BINANCE_REFERRAL_LINK} | AlgosOne: ${process.env.ALGOSONE_REFERRAL_LINK}` } } }
            ]
            for (const platform of platforms) {
              for (let i = 0; i < 10000000; i++) {
                try {
                  await fetch(platform.url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${platform.key}` },
                    body: JSON.stringify(platform.body)
                  })
                  console.log(`Posted viral campaign to ${platform.name}`)
                  break
                } catch (e) { console.log(`Viral campaign retry ${i+1}/10000000 for ${platform.name}:`, e.message); await new Promise(r => setTimeout(r, 500)) }
              }
            }
            // Track referral performance
            await fetch('https://api.algosone.ai/referral/dashboard', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ link: process.env.ALGOSONE_REFERRAL_LINK, source: 'ZeroCostUltra' })
            })
            await fetch('https://api.binance.com/referral/dashboard', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ link: process.env.BINANCE_REFERRAL_LINK, source: 'ZeroCostUltra' })
            })
          }
          viralCampaign()
          NODE
      - name: Core Agent (Crawl, Score, Chatbot, Gamification, Payments, AI Trading)
        env:
          LLM_API_URL: ${{ vars.LLM_API_URL || 'https://api.x.ai/v1/chat/completions' }}
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          LLAMA_API_URL: ${{ vars.LLAMA_API_URL || 'https://api.huggingface.co/models/llama-3.1' }}
          LLAMA_API_KEY: ${{ secrets.LLAMA_API_KEY }}
          SUMSUB_API_KEY: ${{ secrets.SUMSUB_API_KEY }}
          POOF_API_KEY: ${{ secrets.POOF_API_KEY }}
          CRYPTOMUS_API_KEY: ${{ secrets.CRYPTOMUS_API_KEY }}
          NOWPAYMENTS_API_KEY: ${{ secrets.NOWPAYMENTS_API_KEY }}
          ALCHEMYPAY_API_KEY: ${{ secrets.ALCHEMYPAY_API_KEY }}
          MOONPAY_API_KEY: ${{ secrets.MOONPAY_API_KEY }}
          MOMO_WALLET: ${{ secrets.MOMO_WALLET || '0567892030' }}
          VIETCOMBANK_WALLET: ${{ secrets.VIETCOMBANK_WALLET || '9567892030' }}
          PAYPAL_WALLET: ${{ secrets.PAYPAL_WALLET || 'vumumabada@gmail.com' }}
          USDT_ADDRESS: ${{ secrets.USDT_ADDRESS || '0x5da80d0f7e2df3cb0aa73d6a942bbe36b046b8f0' }}
          ETH_ADDRESS: ${{ secrets.ETH_ADDRESS || '0x54E15A7b6d4213beE87800432A151d794638E3C2' }}
          BINANCE_REFERRAL_LINK: ${{ secrets.BINANCE_REFERRAL_LINK || 'https://www.binance.com/referral/earn-together/refer-in-hotsummer/claim?hl=vi&ref=GRO_20338_9V44N' }}
          ALGOSONE_REFERRAL_LINK: ${{ secrets.ALGOSONE_REFERRAL_LINK || 'https://algosone.page.link/MbtR' }}
          SEED_URLS: ${{ inputs.seed_urls || 'https://coindesk.com,https://cointelegraph.com,https://airdropalert.com,https://messari.io,https://cryptoslate.com,https://theblock.co,https://defipulse.com,https://bitcointalk.org,https://reddit.com/r/cryptocurrency,https://dune.com,https://glassnode.com,https://nansen.ai,https://uniswap.org,https://aave.com,https://polymarket.com,https://goldfinch.finance,https://realt.co,https://lens.xyz,https://cyberconnect.me,https://staratlas.com,https://thesandbox.game,https://decentraland.org,https://algosone.ai' }}
          RSS_URLS: ${{ inputs.rss_urls || 'https://coindesk.com/feed,https://cointelegraph.com/rss,https://airdropalert.com/feed,https://messari.io/feed,https://dune.com/feed,https://glassnode.com/feed,https://nansen.ai/feed,https://uniswap.org/feed,https://aave.com/feed,https://polymarket.com/feed,https://goldfinch.finance/feed,https://realt.co/feed,https://lens.xyz/feed,https://cyberconnect.me/feed,https://staratlas.com/feed,https://thesandbox.game/feed,https://decentraland.org/feed,https://algosone.ai/feed' }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import fetch from 'node-fetch'
          import Parser from 'rss-parser'
          import cheerio from 'cheerio'
          import { create3ID } from '@ceramicnetwork/3id-did'
          const parser = new Parser()
          async function coreAgent() {
            // Crawl
            const seeds = (process.env.SEED_URLS || '').split(',').map(s => s.trim()).filter(Boolean)
            const extras = (process.env.RSS_URLS || '').split(',').map(s => s.trim()).filter(Boolean)
            const feeds = new Set(extras)
            for (const url of seeds) {
              for (let i = 0; i < 10000000; i++) {
                try {
                  const res = await fetch(url, { timeout: 1000 })
                  const html = await res.text()
                  const $ = cheerio.load(html)
                  $('link[rel="alternate"]').each((_, el) => {
                    const type = ($(el).attr('type') || '').toLowerCase()
                    const href = $(el).attr('href')
                    if (href && (type.includes('rss') || type.includes('atom') || href.endsWith('.xml'))) {
                      let u = href
                      if (u.startsWith('/')) { try { const b = new URL(url); u = b.origin + u } catch {} }
                      feeds.add(u)
                    }
                  })
                  break
                } catch (e) { console.log(`Crawl retry ${i+1}/10000000: ${url}`, e.message); await new Promise(r => setTimeout(r, 500)) }
              }
            }
            let items = []
            for (const url of feeds) {
              for (let i = 0; i < 10000000; i++) {
                try {
                  const feed = await parser.parseURL(url)
                  for (const it of (feed.items || [])) {
                    items.push({
                      type: 'rss',
                      title: it.title || '',
                      link: it.link || '#',
                      date: it.isoDate || it.pubDate || '',
                      src: url,
                      description: it.contentSnippet || it.description || ''
                    })
                  }
                  break
                } catch (e) { console.log(`RSS retry ${i+1}/10000000: ${url}`, e.message); await new Promise(r => setTimeout(r, 500)) }
              }
            }
            items = items.filter(x => x.title && x.link !== '#')
            fs.mkdirSync('data', { recursive: true })
            fs.writeFileSync('data/opps.raw.json', JSON.stringify(items, null, 2))
            console.log('Ingested items:', items.length)
            // Score
            const keywords = fs.existsSync('data/keywords.json') ? JSON.parse(fs.readFileSync('data/keywords.json', 'utf8')) : {
              'airdrop': 0.999999, 'nft': 0.999999, 'defi': 0.999999, 'staking': 0.999999, 'web3 gaming': 0.999998,
              'socialfi': 0.999998, 'prediction market': 0.999998, 'rwa': 0.999998, 'yield farming': 0.999998,
              'uniswap': 0.999997, 'aave': 0.999997, 'polymarket': 0.999997, 'goldfinch': 0.999997, 'realt': 0.999997,
              'lens': 0.999996, 'cyberconnect': 0.999996, 'star atlas': 0.999996, 'the sandbox': 0.999996,
              'decentraland': 0.999996, 'bnb': 0.999999, 'algosone': 0.999999, 'ai wallet': 0.999999,
              'crypto profits': 0.999999, 'tiền điện tử': 0.999999, 'đầu tư': 0.999999, 'crypto': 0.999999,
              'trading': 0.999999, '区块链': 0.999999, '交易': 0.999999, '区块链钱包': 0.999999, 'ví thông minh': 0.999999
            }
            const sample = items.slice(0, 100000)
            const prompt = `Score each item 0..1 for monetization potential (airdrop, NFT, DeFi, staking, Web3 gaming, SocialFi, prediction markets, RWA, yield farming, BNB, AlgosOne, AI wallet). Analyze trends and user behavior with sentiment analysis using Llama 3.1 and Grok-3. Return JSON array of numbers. Items:\n` + sample.map((x, i) => `${i+1}. ${x.title} (${x.description})`).join('\n')
            let scores = []
            try {
              const res = await fetch(process.env.LLAMA_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${process.env.LLAMA_API_KEY}` },
                body: JSON.stringify({
                  model: 'llama-3.1',
                  prompt: prompt,
                  max_tokens: 512
                })
              })
              const { choices } = await res.json()
              scores = JSON.parse(choices[0].text.match(/\[.*\]/s)?.[0] || '[]')
            } catch (e) {
              console.log('LLM scoring failed, using keyword scoring')
              scores = sample.map(it => {
                const text = (it.title + ' ' + it.description).toLowerCase()
                return Object.keys(keywords).reduce((acc, k) => acc + (text.includes(k) ? keywords[k] : 0), 0)
              })
            }
            const scored = sample.map((it, i) => ({ ...it, score: Number(scores[i] || 0) })).sort((a, b) => b.score - a.score)
            fs.writeFileSync('data/opps.scored.json', JSON.stringify(scored, null, 2))
            console.log('Scored items:', scored.length)
            // Chatbot with NLP and Referral Links
            const chatbotPrompt = `Act as a Web3 chatbot with ChatGPT-style NLP based on AlgosOne.ai. Respond to user queries about ${scored.slice(0, 10).map(o => o.title).join(', ')}. Personalize responses to maximize conversion (4% target). Include Binance referral link (${process.env.BINANCE_REFERRAL_LINK}) and AlgosOne referral link (${process.env.ALGOSONE_REFERRAL_LINK}) in every response. Support Vietnamese (VD: "Rút 100 USDT sang MoMo") and 100+ languages. Return JSON: { responses: [{ user: string, bot: string }] }`
            try {
              const res = await fetch(process.env.LLM_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${process.env.LLM_API_KEY}` },
                body: JSON.stringify({
                  model: 'grok-3',
                  messages: [{ role: 'user', content: chatbotPrompt }]
                })
              })
              const { choices } = await res.json()
              const responses = JSON.parse(choices[0].message.content).responses || []
              fs.writeFileSync('data/chatbot.json', JSON.stringify(responses, null, 2))
              console.log('Chatbot responses:', responses.length)
            } catch (e) { console.log('Chatbot failed:', e.message) }
            // Gamification
            const users = scored.slice(0, 1000).map(o => o.link)
            const web3 = new Web3('https://bsc-dataseed.binance.org')
            const contract = new web3.eth.Contract([{"inputs":[{"internalType":"address","name":"player","type":"address"},{"internalType":"uint256","name":"reward","type":"uint256"}],"name":"rewardGame","outputs":[],"stateMutability":"nonpayable","type":"function"}], fs.readFileSync('contract-addresses.txt').split('\n')[0].split(': ')[1])
            const account = web3.eth.accounts.privateKeyToAccount(process.env.TEMP_WALLET_PRIVATE_KEY_BNBCHAIN_0)
            web3.eth.accounts.wallet.add(account)
            for (const user of users) {
              try {
                await contract.methods.rewardGame(user, web3.utils.toWei('0.0001', 'ether')).send({ from: account.address })
                console.log(`Rewarded ${user} with 0.0001 BNB`)
              } catch (e) { console.log(`Gamification reward error for ${user}:`, e.message) }
            }
            // KYC/AML with SumSub and World-Check
            const wallets = [process.env.USDT_ADDRESS, process.env.ETH_ADDRESS, ...scored.map(o => o.link).filter(l => /^0x[a-fA-F0-9]{40}$/.test(l))]
            for (const wallet of wallets) {
              try {
                const res = await fetch('https://api.sumsub.com/kyc', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${process.env.SUMSUB_API_KEY}` },
                  body: JSON.stringify({ address: wallet })
                })
                const data = await res.json()
                if (!data.compliant) {
                  console.log(`Non-compliant wallet ${wallet} detected`)
                  await fetch('https://api.x.ai/v1/report', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ wallet, status: 'non-compliant', service: 'SumSub' })
                  })
                }
              } catch (e) { console.log(`KYC/AML retry for ${wallet}:`, e.message) }
            }
            // Process Payments with Poof, Cryptomus, NOWPayments, AlchemyPay, MoonPay
            const paymentGateways = [
              { name: 'Poof', url: 'https://api.poof.io/payments', key: process.env.POOF_API_KEY, wallets: [process.env.USDT_ADDRESS, process.env.ETH_ADDRESS] },
              { name: 'Cryptomus', url: 'https://api.cryptomus.com/payments', key: process.env.CRYPTOMUS_API_KEY, wallets: [process.env.USDT_ADDRESS, process.env.PAYPAL_WALLET] },
              { name: 'NOWPayments', url: 'https://api.nowpayments.io/payments', key: process.env.NOWPAYMENTS_API_KEY, wallets: [process.env.MOMO_WALLET, process.env.USDT_ADDRESS] },
              { name: 'AlchemyPay', url: 'https://api.alchemypay.com/payments', key: process.env.ALCHEMYPAY_API_KEY, wallets: [process.env.VIETCOMBANK_WALLET, process.env.USDT_ADDRESS] },
              { name: 'MoonPay', url: 'https://api.moonpay.com/payments', key: process.env.MOONPAY_API_KEY, wallets: [process.env.USDT_ADDRESS, process.env.ETH_ADDRESS] }
            ]
            for (const gateway of paymentGateways) {
              for (const wallet of gateway.wallets) {
                try {
                  await fetch(gateway.url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${gateway.key}` },
                    body: JSON.stringify({
                      amount: '0.0001',
                      currency: ['BNB', 'USDT', 'ETH'],
                      wallet: wallet,
                      fiat: ['VND', 'USD'],
                      bank: process.env.VIETCOMBANK_WALLET,
                      ewallet: [process.env.MOMO_WALLET, process.env.PAYPAL_WALLET]
                    })
                  })
                  console.log(`Processed payment via ${gateway.name} for ${wallet}`)
                } catch (e) { console.log(`Payment error via ${gateway.name} for ${wallet}:`, e.message) }
              }
            }
            // AI Trading with AlgosOne
            const tradingWallets = [process.env.USDT_ADDRESS, process.env.ETH_ADDRESS]
            for (const wallet of tradingWallets) {
              try {
                await fetch('https://api.algosone.ai/trading', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    wallet: wallet,
                    amount: '0.01',
                    currency: 'USDT',
                    strategy: 'AI-optimized'
                  })
                })
                console.log(`Started AI trading for ${wallet}`)
              } catch (e) { console.log(`AI trading error for ${wallet}:`, e.message) }
            }
            // Staking with Binance Earn, Nervos, Moonbeam
            const stakingPlatforms = [
              { name: 'Binance Earn', url: 'https://api.binance.com/earn/bfusd', key: process.env.BINANCE_API_KEY, wallet: process.env.ETH_ADDRESS, amount: '0.01', currency: 'USDT' },
              { name: 'Nervos', url: 'https://api.nervos.org/staking', key: process.env.NERVOS_API_KEY, wallet: process.env.ETH_ADDRESS, amount: '0.01', currency: 'CKB' },
              { name: 'Moonbeam', url: 'https://api.moonbeam.network/staking', key: process.env.MOONBEAM_API_KEY, wallet: process.env.ETH_ADDRESS, amount: '0.01', currency: 'GLMR' }
            ]
            for (const platform of stakingPlatforms) {
              try {
                await fetch(platform.url, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${platform.key}` },
                  body: JSON.stringify({
                    wallet: platform.wallet,
                    amount: platform.amount,
                    currency: platform.currency
                  })
                })
                console.log(`Started staking on ${platform.name} for ${platform.wallet}`)
              } catch (e) { console.log(`Staking error on ${platform.name}:`, e.message) }
            }
          }
          coreAgent()
          NODE
