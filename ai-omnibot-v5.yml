name: ai-omnibot-v15-infinity

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      mode:
        description: "Run mode"
        type: choice
        default: infinity
        options: [infinity]
      rss_urls:
        description: "CSV RSS URLs (override)"
        required: false
      seed_urls:
        description: "CSV seed websites to discover RSS (override)"
        required: false
      confidence_threshold:
        description: "AI score threshold 0..1 for LIVE actions"
        default: "0.9999"
  schedule:
    - cron: "*/10 * * * *"  # Run every 10 seconds

permissions:
  contents: write
  issues: write
  pull-requests: write
  models: read
  actions: write

concurrency:
  group: ai-omnibot-v15-infinity-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: false

jobs:
  initialize:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-configure environment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          KILL_SWITCH: ${{ secrets.KILL_SWITCH }}
          PINATA_API_KEY: ${{ secrets.PINATA_API_KEY }}
          FLEEK_API_KEY: ${{ secrets.FLEEK_API_KEY }}
          WEB3_STORAGE_API_KEY: ${{ secrets.WEB3_STORAGE_API_KEY }}
          ARWEAVE_KEY: ${{ secrets.ARWEAVE_KEY }}
          FILECOIN_API_KEY: ${{ secrets.FILECOIN_API_KEY }}
          STORJ_API_KEY: ${{ secrets.STORJ_API_KEY }}
          CHAINALYSIS_API_KEY: ${{ secrets.CHAINALYSIS_API_KEY }}
          ELLIPTIC_API_KEY: ${{ secrets.ELLIPTIC_API_KEY }}
          CIPHERTACE_API_KEY: ${{ secrets.CIPHERTACE_API_KEY }}
          NOSTR_PRIVATE_KEY: ${{ secrets.NOSTR_PRIVATE_KEY }}
          RADICLE_TOKEN: ${{ secrets.RADICLE_TOKEN }}
          CERAMIC_SEED: ${{ secrets.CERAMIC_SEED }}
          SKYNET_KEY: ${{ secrets.SKYNET_KEY }}
          SWARM_KEY: ${{ secrets.SWARM_KEY }}
          HYPERLEDGER_KEY: ${{ secrets.HYPERLEDGER_KEY }}
        run: |
          echo "## Initializing Infinity" >> $GITHUB_STEP_SUMMARY
          if [ -z "$KILL_SWITCH" ]; then
            curl -s -X PUT \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -d '{"encrypted_value":"T05F"}' \
              "https://api.github.com/repos/${{ github.repository }}/actions/secrets/KILL_SWITCH"
            echo "Set KILL_SWITCH=ON" >> $GITHUB_STEP_SUMMARY
          fi
          node --input-type=module - <<'NODE'
          import fetch from 'node-fetch'
          async function registerServices() {
            const services = [
              { name: 'Pinata', url: 'https://api.pinata.cloud/users/register', keys: ['PINATA_API_KEY', 'PINATA_API_SECRET'] },
              { name: 'Fleek', url: 'https://api.fleek.co/register', keys: ['FLEEK_API_KEY'] },
              { name: 'Web3.Storage', url: 'https://api.web3.storage/register', keys: ['WEB3_STORAGE_API_KEY'] },
              { name: 'Arweave', url: 'https://arweave.net/register', keys: ['ARWEAVE_KEY'] },
              { name: 'Filecoin', url: 'https://api.filecoin.io/register', keys: ['FILECOIN_API_KEY'] },
              { name: 'Storj', url: 'https://api.storj.io/register', keys: ['STORJ_API_KEY'] },
              { name: 'Radicle', url: 'https://api.radicle.network/register', keys: ['RADICLE_TOKEN'] },
              { name: 'Ceramic', url: 'https://ceramic.network/register', keys: ['CERAMIC_SEED'] },
              { name: 'Skynet', url: 'https://siasky.net/register', keys: ['SKYNET_KEY'] },
              { name: 'Swarm', url: 'https://api.swarm.network/register', keys: ['SWARM_KEY'] },
              { name: 'Hyperledger', url: 'https://api.hyperledger.org/register', keys: ['HYPERLEDGER_KEY'] },
              { name: 'Chainalysis', url: 'https://api.chainalysis.com/register', keys: ['CHAINALYSIS_API_KEY'] },
              { name: 'Elliptic', url: 'https://api.elliptic.co/register', keys: ['ELLIPTIC_API_KEY'] },
              { name: 'CipherTrace', url: 'https://api.ciphertrace.com/register', keys: ['CIPHERTACE_API_KEY'] },
              { name: 'Nostr', url: 'https://nostr.network/register', keys: ['NOSTR_PRIVATE_KEY'] }
            ]
            for (const { name, url, keys } of services) {
              for (let i = 0; i < 10000; i++) {
                try {
                  const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: `temp-${Date.now()}-${i}@${name.toLowerCase()}.com`, password: 'InfinityPass123!' })
                  })
                  const data = await res.json()
                  for (const key of keys) {
                    const val = data[key.split('_')[0].toLowerCase()] || data[key.toLowerCase()] || data.apiKey || data.key || data.seed || data.token
                    if (val) {
                      await fetch(`https://api.github.com/repos/${{ github.repository }}/actions/secrets/${key}_${i}`, {
                        method: 'PUT',
                        headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                        body: JSON.stringify({ encrypted_value: val })
                      })
                      console.log(`Registered ${name} ${key}_${i}`)
                    }
                  }
                  break
                } catch (e) { console.log(`${name} registration retry ${i+1}/10000:`, e.message); await new Promise(r => setTimeout(r, 1000)) }
              }
            }
            // Generate 10,000 wallets per blockchain
            const blockchains = ['Polygon', 'Solana', 'Arbitrum', 'Optimism', 'Binance', 'Avalanche', 'Cardano', 'Polkadot', 'Aptos', 'Sui', 'Near', 'Cosmos', 'Starknet', 'ZkSync', 'Flow', 'Hedera', 'Tezos', 'Algorand']
            const Web3 = (await import('web3')).default
            const web3 = new Web3()
            for (const chain of blockchains) {
              for (let i = 0; i < 10000; i++) {
                const account = web3.eth.accounts.create()
                await fetch(`https://api.github.com/repos/${{ github.repository }}/actions/secrets/TEMP_WALLET_PRIVATE_KEY_${chain}_${i}`, {
                  method: 'PUT',
                  headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                  body: JSON.stringify({ encrypted_value: account.privateKey })
                })
                await fetch(`https://api.github.com/repos/${{ github.repository }}/actions/secrets/TEMP_WALLET_ADDRESS_${chain}_${i}`, {
                  method: 'PUT',
                  headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                  body: JSON.stringify({ encrypted_value: account.address })
                })
                console.log(`Generated wallet ${chain}_${i}:`, account.address)
              }
            }
            // Backup to decentralized platforms
            const platforms = ['https://api.gitlab.com', 'https://api.bitbucket.org', 'https://sourcehut.org/api', 'https://radicle.network/api', 'https://ceramic.network/api', 'https://siasky.net/api', 'https://swarm.network/api', 'https://hyperledger.org/api']
            for (const platform of platforms) {
              try {
                await fetch(`${platform}/repos`, {
                  method: 'POST',
                  headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Content-Type': 'application/json' },
                  body: JSON.stringify({ name: 'ai-omnibot-v15-backup', source: 'github.com/${{ github.repository }}' })
                })
                console.log(`Backed up to ${platform}`)
              } catch (e) { console.log(`Backup error on ${platform}:`, e.message) }
            }
            // Encode wallets and affiliate links in Arweave
            const wallets = [
              { type: 'USDT', address: '0x5da80d0f7e2df3cb0aa73d6a942bbe36b046b8f0' },
              { type: 'ETH', address: '0x54E15A7b6d4213beE87800432A151d794638E3C2' },
              { type: 'MoMo', address: '0567892030' },
              { type: 'VCB', address: '9567892030' },
              { type: 'PayPal', address: 'vumumabada@gmail.com' }
            ]
            const affiliates = [
              { name: 'Binance', link: 'https://www.binance.com/referral/earn-together/refer-in-hotsummer/claim?hl=vi&ref=GRO_20338_9V44N' },
              { name: 'AlgosOne', link: 'https://algosone.page.link/MbtR' }
            ]
            for (const wallet of wallets) {
              await fetch('https://arweave.net/tx', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: JSON.stringify(wallet), tags: [{ name: 'InfinityBot', value: 'v15' }, { name: 'Wallet', value: wallet.type }] })
              })
            }
            for (const affiliate of affiliates) {
              await fetch('https://arweave.net/tx', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: JSON.stringify(affiliate), tags: [{ name: 'InfinityBot', value: 'v15' }, { name: 'Affiliate', value: affiliate.name }] })
              })
            }
          }
          registerServices()
          NODE
          # Bootstrap capital from faucets
          node --input-type=module - <<'NODE'
          import fetch from 'node-fetch'
          async function bootstrapCapital() {
            const faucets = [
              'https://faucet.polygon.technology', 'https://faucet.solana.com', 'https://faucet.arbitrum.io',
              'https://faucet.optimism.io', 'https://testnet.bnbchain.org/faucet', 'https://faucet.avax.network',
              'https://faucet.cardano.org', 'https://faucet.polkadot.io', 'https://faucet.aptoslabs.com',
              'https://faucet.sui.io', 'https://faucet.near.org', 'https://faucet.cosmos.network',
              'https://faucet.starknet.io', 'https://faucet.zksync.io', 'https://faucet.flow.com',
              'https://faucet.hedera.com', 'https://faucet.tezos.com', 'https://faucet.algorand.org'
            ]
            for (const faucet of faucets) {
              for (let i = 0; i < 10000; i++) {
                try {
                  await fetch(faucet, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: process.env[`TEMP_WALLET_ADDRESS_${faucet.split('.')[1].toUpperCase()}_${i}`] })
                  })
                  console.log(`Requested faucet from ${faucet} for wallet ${i}`)
                } catch (e) { console.log(`Faucet error ${faucet} wallet ${i}:`, e.message) }
              }
            }
          }
          bootstrapCapital()
          NODE

  run:
    runs-on: ubuntu-latest
    needs: initialize
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          npm i rss-parser@3 node-fetch@3 cheerio@1 qrcode@1 @pinata/sdk@2 @fleekhq/fleek-sdk@1 web3@1 @web3-storage/client@1 @arweave/arweave-js@1 @filecoin/js-filecoin@1 @storj/storj-js@1 @xai/grok-sdk@0.1.0 ethers@5 web3modal@2 walletconnect/web3-provider@1 three@0.132.2 nostr-tools@1 @radicle/radicle-sdk@0.5.0 @ceramicnetwork/3id-did@1 @siasky/skynet-js@1 @swarm/swarm-js@1 @hyperledger/fabric-sdk@1 @elliptic/elliptic-js@1 @ciphertrace/ciphertrace-js@1

      # ================== AGENT: DEPLOY SMART CONTRACT ==================
      - name: Deploy Smart Contract
        env:
          TEMP_WALLET_PRIVATE_KEY_POLYGON_0: ${{ secrets.TEMP_WALLET_PRIVATE_KEY_POLYGON_0 }}
          TEMP_WALLET_ADDRESS_POLYGON_0: ${{ secrets.TEMP_WALLET_ADDRESS_POLYGON_0 }}
        run: |
          node --input-type=module - <<'NODE'
          import Web3 from 'web3'
          import fs from 'fs'
          const blockchains = [
            { name: 'Polygon', rpc: 'https://rpc-mainnet.maticvigil.com', stake: '0xAavePolygonContract' },
            { name: 'Solana', rpc: 'https://api.mainnet-beta.solana.com', stake: '0xSolanaProgram' },
            { name: 'Arbitrum', rpc: 'https://arb1.arbitrum.io/rpc', stake: '0xCompoundArbitrum' },
            { name: 'Optimism', rpc: 'https://mainnet.optimism.io', stake: '0xAaveOptimism' },
            { name: 'Binance', rpc: 'https://bsc-dataseed.binance.org/', stake: '0xPancakeSwap' },
            { name: 'Avalanche', rpc: 'https://api.avax.network/ext/bc/C/rpc', stake: '0xTraderJoe' },
            { name: 'Cardano', rpc: 'https://rpc.cardano.org', stake: '0xMinswap' },
            { name: 'Polkadot', rpc: 'https://rpc.polkadot.io', stake: '0xAcala' },
            { name: 'Aptos', rpc: 'https://fullnode.mainnet.aptoslabs.com', stake: '0xPancakeAptos' },
            { name: 'Sui', rpc: 'https://rpc.mainnet.sui.io', stake: '0xCetus' },
            { name: 'Near', rpc: 'https://rpc.mainnet.near.org', stake: '0xRefFinance' },
            { name: 'Cosmos', rpc: 'https://rpc.cosmos.network', stake: '0xOsmosis' },
            { name: 'Starknet', rpc: 'https://rpc.starknet.io', stake: '0xStarkDeFi' },
            { name: 'ZkSync', rpc: 'https://rpc.zksync.io', stake: '0xSyncSwap' },
            { name: 'Flow', rpc: 'https://mainnet.flow.com', stake: '0xFlowStake' },
            { name: 'Hedera', rpc: 'https://mainnet.hedera.com', stake: '0xHederaStake' },
            { name: 'Tezos', rpc: 'https://mainnet.tezos.com', stake: '0xTezosStake' },
            { name: 'Algorand', rpc: 'https://mainnet.algorand.org', stake: '0xAlgorandStake' }
          ]
          const contractABI = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"donor","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"string","name":"currency","type":"string"}],"name":"Donated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"NFTMinted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"subscriber","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"string","name":"currency","type":"string"}],"name":"Subscribed","type":"event"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"currency","type":"string"}],"name":"donate","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"mintNFT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"currency","type":"string"}],"name":"subscribe","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"subscribers","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalDonations","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSubscriptions","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}]
          const contractBytecode = "0x608060405234801561001057600080fd5b506102c3806100206000396000f3fe60806040526004361061004e5760003560e01c80633ccfd60b146100575780638da5cb5b1461006e578063a6f9dae11461009f578063d0e30db0146100bf578063f10fdf5c146100d7578063f2b1b8821461010a57610055565b3661005557005b600080fd5b34801561006357600080fd5b5061006c61012a565b005b34801561007a57600080fd5b50600054610087906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b3480156100ab57600080fd5b5061006c6100ba36600461024c565b61013e565b6100d56100d536600461026e565b61015e565b005b3480156100e357600080fd5b506100f76100f2366004610290565b6101b0565b60405190815260200160405180910390f35b34801561011657600080fd5b5061012060015481565b6040519081526020016100f7565b6000546001600160a01b0316331461013d57600080fd5b005b6000546001600160a01b0316331461015557600080fd5b61013d6101e8565b6040516323b872dd60e01b81523360048201523060248201526044820181905260009081906064906000856001600160a01b03168663a9059cbb60e01b9060840160408051601f198184030181529181526020820180516001600160e01b031663a9059cbb60e01b1790528151600094859450909250871692506101e49150829060240190565b60405180910390a150565b6000805460405160016000160a01b0390911690600081818185875af1925050503d8060008114610237576040519150601f19603f3d011682016040523d82523d6000602084013e61023c565b606091505b50509050565b60006020828403121561025e57600080fd5b81356001600160a01b03169050919050565b6000806040838503121561028157600080fd5b50508035936020909101359150565b6000602082840312156102a257600080fd5b503591905056"
          async function deployContract() {
            for (const chain of blockchains) {
              for (let i = 0; i < 10000; i++) {
                try {
                  const web3 = new Web3(chain.rpc)
                  const account = web3.eth.accounts.privateKeyToAccount(process.env[`TEMP_WALLET_PRIVATE_KEY_${chain}_${i}`] || process.env.TEMP_WALLET_PRIVATE_KEY_POLYGON_0)
                  web3.eth.accounts.wallet.add(account)
                  const contract = new web3.eth.Contract(contractABI)
                  const deployTx = contract.deploy({ data: contractBytecode })
                  const gas = await deployTx.estimateGas({ from: account.address })
                  const tx = await deployTx.send({ from: account.address, gas })
                  fs.appendFileSync('contract-addresses.txt', `${chain.name}_${i}: ${tx.options.address}\n`)
                  const userWallets = [
                    '0x5da80d0f7e2df3cb0aa73d6a942bbe36b046b8f0',
                    '0x54E15A7b6d4213beE87800432A151d794638E3C2',
                    '0567892030',
                    '9567892030',
                    'vumumabada@gmail.com'
                  ]
                  for (const wallet of userWallets) {
                    await web3.eth.sendTransaction({ from: account.address, to: wallet, value: web3.utils.toWei('0.001', 'ether') })
                  }
                  console.log(`Contract deployed on ${chain.name}_${i}:`, tx.options.address)
                  break
                } catch (e) { console.error(`Contract deploy error on ${chain.name}_${i}:`, e.message); await new Promise(r => setTimeout(r, 1000)) }
              }
            }
          }
          deployContract()
          NODE

      # ================== AGENT: CRAWLER ==================
      - name: Agent: Crawler
        env:
          SEED_URLS: ${{ inputs.seed_urls || 'https://coindesk.com,https://cointelegraph.com,https://airdropalert.com,https://bitcointalk.org,https://reddit.com/r/cryptocurrency,https://news.bitcoin.com,https://theblock.co,https://producthunt.com,https://techcrunch.com,https://defillama.com,https://farcaster.network,https://lens.xyz,https://coingecko.com,https://coinmarketcap.com,https://dune.com,https://zora.co,https://opensea.io,https://blur.io,https://nostr.com,https://decentraland.org,https://sandbox.game,https://axieinfinity.com,https://illuvium.io,https://staratlas.com,https://polymarket.com,https://augur.net,https://gitcoin.co,https://dorahacks.io,https://centrifuge.io,https://realt.co,https://steemit.com,https://hive.io,https://bitclout.com,https://signal.org,https://matrix.org,https://mastodon.social,https://weibo.com,https://vk.com' }}
          EXTRA_RSS: ${{ inputs.rss_urls || 'https://coindesk.com/feed,https://cointelegraph.com/rss,https://airdropalert.com/feed,https://news.bitcoin.com/feed,https://coingecko.com/feed,https://coinmarketcap.com/feed,https://defillama.com/feed,https://zora.co/feed,https://nostr.com/feed,https://axieinfinity.com/feed,https://illuvium.io/feed,https://polymarket.com/feed,https://gitcoin.co/feed,https://centrifuge.io/feed,https://signal.org/feed,https://matrix.org/feed,https://mastodon.social/feed,https://weibo.com/feed,https://vk.com/feed' }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import fetch from 'node-fetch'
          import cheerio from 'cheerio'
          const seeds = (process.env.SEED_URLS || '').split(',').map(s => s.trim()).filter(Boolean)
          const extras = (process.env.EXTRA_RSS || '').split(',').map(s => s.trim()).filter(Boolean)
          const out = new Set(extras)
          for (const url of seeds) {
            for (let i = 0; i < 10000; i++) {
              try {
                const res = await fetch(url, { timeout: 3000 })
                const html = await res.text()
                const $ = cheerio.load(html)
                $('link[rel="alternate"]').each((_, el) => {
                  const type = ($(el).attr('type') || '').toLowerCase()
                  const href = $(el).attr('href')
                  if (href && (type.includes('rss') || type.includes('atom') || href.endsWith('.xml'))) {
                    let u = href
                    if (u.startsWith('/')) { try { const b = new URL(url); u = b.origin + u } catch {} }
                    out.add(u)
                  }
                })
                const sm = url.replace(/\/+$/, '') + '/sitemap.xml'
                out.add(sm)
                break
              } catch (e) { console.log(`Seed retry ${i+1}/10000: ${url}`, e.message); await new Promise(r => setTimeout(r, 1000)) }
            }
          }
          const feeds = [...out].filter(u => /(\.xml|feed|rss|atom)/i.test(u))
          fs.mkdirSync('data', { recursive: true })
          fs.writeFileSync('data/feeds.txt', feeds.join('\n') + '\n')
          console.log('Discovered feeds:', feeds.length)
          NODE

      # ================== AGENT: INGEST ==================
      - name: Agent: Ingest
        env:
          FEEDS_FILE: data/feeds.txt
          RSS_URLS: ${{ inputs.rss_urls || 'https://coindesk.com/feed,https://cointelegraph.com/rss,https://airdropalert.com/feed,https://news.bitcoin.com/feed,https://coingecko.com/feed,https://coinmarketcap.com/feed,https://defillama.com/feed,https://zora.co/feed,https://nostr.com/feed,https://axieinfinity.com/feed,https://illuvium.io/feed,https://polymarket.com/feed,https://gitcoin.co/feed,https://centrifuge.io/feed,https://signal.org/feed,https://matrix.org/feed,https://mastodon.social/feed,https://weibo.com/feed,https://vk.com/feed' }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import Parser from 'rss-parser'
          const parser = new Parser()
          async function fetchWithRetry(url, retries = Infinity) {
            for (let i = 0; i < retries; i++) {
              try {
                const res = await parser.parseURL(url)
                return res
              } catch (e) {
                console.log(`RSS retry ${i+1}: ${url}`, e.message)
                await new Promise(resolve => setTimeout(resolve, 1000))
              }
            }
            return null
          }
          let feeds = []
          try {
            feeds = (fs.existsSync(process.env.FEEDS_FILE) ? fs.readFileSync(process.env.FEEDS_FILE, 'utf8') : '')
              .split('\n').map(s => s.trim()).filter(Boolean)
          } catch {}
          const extra = (process.env.RSS_URLS || '').split(',').map(s => s.trim()).filter(Boolean)
          const all = [...new Set([...feeds, ...extra])]
          let items = []
          for (const url of all) {
            const feed = await fetchWithRetry(url)
            if (feed) {
              for (const it of (feed.items || [])) {
                items.push({
                  type: 'rss',
                  title: it.title || '',
                  link: it.link || '#',
                  date: it.isoDate || it.pubDate || '',
                  src: url,
                  description: it.contentSnippet || it.description || ''
                })
              }
            }
          }
          items = items.filter(x => x.title && x.link !== '#')
          fs.mkdirSync('data', { recursive: true })
          fs.writeFileSync('data/opps.raw.json', JSON.stringify(items, null, 2))
          console.log('Ingested items:', items.length)
          NODE

      # ================== AGENT: SCORER ==================
      - name: Agent: Scorer
        env:
          LLM_API_URL: ${{ vars.LLM_API_URL || 'https://api.x.ai/v1/chat/completions' }}
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          LLM_MODEL: ${{ vars.LLM_MODEL || 'grok-3' }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import fetch from 'node-fetch'
          const raw = 'data/opps.raw.json'
          const items = fs.existsSync(raw) ? JSON.parse(fs.readFileSync(raw, 'utf8')) : []
          async function llmScore(arr) {
            const url = process.env.LLM_API_URL, key = process.env.LLM_API_KEY
            if (!url || !key) {
              console.log('No LLM credentials, falling back to keyword scoring')
              return null
            }
            try {
              const prompt = `Score each item 0..1 for monetization potential (airdrop, affiliate, referral, high yield, exclusive offer, trading, NFT, DeFi, staking, memecoin, Web3 gaming, SocialFi, prediction markets, crowdfunding, tokenized assets, RWA, DAOs, yield farming, liquidity mining, play-to-earn, vote-to-earn, trending on X/Farcaster/Lens/Nostr/CoinGecko/CoinMarketCap/Dune). Analyze user behavior, trends, and keywords at a molecular level. Return a JSON array of numbers with length=${arr.length}. Items:\n` + arr.map((x, i) => `${i+1}. ${x.title} (${x.description})`).join('\n')
              const body = {
                model: process.env.LLM_MODEL || 'grok-3',
                messages: [
                  { role: 'system', content: 'Output only a JSON array of numbers 0..1. Optimize for high-yield Web3 opportunities with 100% legal compliance and molecular-level trend analysis.' },
                  { role: 'user', content: prompt }
                ]
              }
              for (let i = 0; i < 10000; i++) {
                try {
                  const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'content-type': 'application/json', 'authorization': `Bearer ${key}` },
                    body: JSON.stringify(body)
                  })
                  const j = await res.json()
                  const txt = j.choices?.[0]?.message?.content || ''
                  const nums = JSON.parse(txt.match(/\[.*\]/s)?.[0] || '[]')
                  return Array.isArray(nums) && nums.length === arr.length ? nums : null
                } catch (e) { console.log(`LLM retry ${i+1}/10000:`, e.message); await new Promise(r => setTimeout(r, 1000)) }
              }
              return null
            } catch (e) {
              console.log('LLM scoring failed:', e.message)
              return null
            }
          }
          let scored = []
          const sample = items.slice(0, 100000)
          const nums = await llmScore(sample)
          if (nums) {
            scored = sample.map((it, i) => ({ ...it, score: Number(nums[i] || 0) })).sort((a, b) => b.score - a.score)
          } else {
            const weights = {
              'free crypto': 0.9999, 'high yield': 0.9999, 'exclusive offer': 0.9999,
              'airdrop': 0.9998, 'referral': 0.9998, 'affiliate': 0.9998, 'bounty': 0.9998,
              'nft': 0.9997, 'defi': 0.9997, 'staking': 0.9997, 'memecoin': 0.9997,
              'web3 gaming': 0.9996, 'socialfi': 0.9996, 'prediction market': 0.9996, 'crowdfunding': 0.9996, 'tokenized asset': 0.9996,
              'rwa': 0.9995, 'dao': 0.9995, 'yield farming': 0.9995, 'liquidity mining': 0.9995, 'play-to-earn': 0.9995, 'vote-to-earn': 0.9995,
              'binance': 0.9994, 'algosone': 0.9994, 'algorand': 0.9994, 'coinbase': 0.9994, 'kucoin': 0.9994, 'bybit': 0.9994, 'okx': 0.9994,
              'axie infinity': 0.9993, 'illuvium': 0.9993, 'star atlas': 0.9993, 'polymarket': 0.9993, 'augur': 0.9993, 'gitcoin': 0.9993, 'dorahacks': 0.9993, 'centrifuge': 0.9993, 'realt': 0.9993,
              'trending': 0.9999, 'farcaster': 0.9998, 'lens': 0.9998, 'nostr': 0.9998, 'coingecko': 0.9997, 'coinmarketcap': 0.9997, 'dune': 0.9997
            }
            scored = items.map(it => {
              const text = ((it.title || '') + ' ' + (it.description || '') + ' ' + (it.src || '')).toLowerCase()
              let score = 0
              for (const [key, weight] of Object.entries(weights)) {
                if (text.includes(key)) score = Math.max(score, weight)
              }
              return { ...it, score }
            }).filter(x => x.score > 0).sort((a, b) => b.score - a.score)
          }
          fs.mkdirSync('data', { recursive: true })
          fs.writeFileSync('data/opps.scored.json', JSON.stringify(scored, null, 2))
          console.log('Scored items:', scored.length)
          NODE

      # ================== AGENT: AFFILIATE ==================
      - name: Agent: Affiliate Map
        env:
          REF_BINANCE: "https://www.binance.com/referral/earn-together/refer-in-hotsummer/claim?hl=vi&ref=GRO_20338_9V44N&utm_source=infinitybot&utm_campaign=v15"
          REF_ALGOSONE: "https://algosone.page.link/MbtR?utm_source=infinitybot&utm_campaign=v15"
          REF_COINBASE: ${{ vars.REF_COINBASE || 'https://www.coinbase.com/referral/your-link' }}
          REF_KUCOIN: ${{ vars.REF_KUCOIN || 'https://www.kucoin.com/referral/your-link' }}
          REF_BYBIT: ${{ vars.REF_BYBIT || 'https://www.bybit.com/referral/your-link' }}
          REF_OKX: ${{ vars.REF_OKX || 'https://www.okx.com/referral/your-link' }}
          AFFILIATE_MAP: ${{ vars.AFFILIATE_MAP }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import fetch from 'node-fetch'
          const p = 'data/opps.scored.json'
          const items = fs.existsSync(p) ? JSON.parse(fs.readFileSync(p, 'utf8')) : []
          let map = {}
          try { map = JSON.parse(process.env.AFFILIATE_MAP || '{}') } catch {}
          if (process.env.REF_BINANCE) map['binance'] = process.env.REF_BINANCE
          if (process.env.REF_ALGOSONE) map['algosone'] = process.env.REF_ALGOSONE
          if (process.env.REF_COINBASE) map['coinbase'] = process.env.REF_COINBASE
          if (process.env.REF_KUCOIN) map['kucoin'] = process.env.REF_KUCOIN
          if (process.env.REF_BYBIT) map['bybit'] = process.env.REF_BYBIT
          if (process.env.REF_OKX) map['okx'] = process.env.REF_OKX
          const brands = new Set()
          for (const it of items) {
            const t = ((it.title || '') + ' ' + (it.description || '')).toLowerCase()
            if (/binance|bnb/.test(t) && !map['binance']) brands.add('binance')
            if (/algosone|algorand|algo/.test(t) && !map['algosone']) brands.add('algosone')
            if (/coinbase/.test(t) && !map['coinbase']) brands.add('coinbase')
            if (/kucoin/.test(t) && !map['kucoin']) brands.add('kucoin')
            if (/bybit/.test(t) && !map['bybit']) brands.add('bybit')
            if (/okx/.test(t) && !map['okx']) brands.add('okx')
          }
          for (const brand of brands) {
            for (let i = 0; i < 10000; i++) {
              try {
                const res = await fetch(`https://api.${brand}.com/affiliate/register`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ email: `temp-${Date.now()}-${i}@${brand}.com`, password: 'InfinityPass123!' })
                })
                const data = await res.json()
                if (data.referralLink) {
                  map[brand] = data.referralLink
                  await fetch(`https://api.github.com/repos/${{ github.repository }}/actions/variables/REF_${brand.toUpperCase()}_${i}`, {
                    method: 'PUT',
                    headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                    body: JSON.stringify({ name: `REF_${brand.toUpperCase()}_${i}`, value: data.referralLink })
                  })
                  console.log(`Auto-registered ${brand} affiliate link ${i}`)
                }
                break
              } catch (e) { console.log(`Affiliate registration retry ${i+1}/10000 for ${brand}:`, e.message); await new Promise(r => setTimeout(r, 1000)) }
            }
          }
          fs.writeFileSync('data/affiliate.map.json', JSON.stringify(map, null, 2))
          console.log('Affiliate map updated:', Object.keys(map).length)
          NODE

      # ================== AGENT: SITE ==================
      - name: Agent: Site Builder
        env:
          PAYMENT_MOMO: "0567892030"
          PAYMENT_VCB: "9567892030"
          PAYMENT_USDT_ERC20: "0x5da80d0f7e2df3cb0aa73d6a942bbe36b046b8f0"
          PAYMENT_ETH: "0x54E15A7b6d4213beE87800432A151d794638E3C2"
          PAYMENT_BTC: $(node -e "const Web3 = require('web3'); console.log(new Web3().eth.accounts.create().address)")
          PAYMENT_PAYPAL: "vumumabada@gmail.com"
          REF_BINANCE: "https://www.binance.com/referral/earn-together/refer-in-hotsummer/claim?hl=vi&ref=GRO_20338_9V44N&utm_source=infinitybot&utm_campaign=v15"
          REF_ALGOSONE: "https://algosone.page.link/MbtR?utm_source=infinitybot&utm_campaign=v15"
          REF_COINBASE: ${{ vars.REF_COINBASE || 'https://www.coinbase.com/referral/your-link' }}
          REF_KUCOIN: ${{ vars.REF_KUCOIN || 'https://www.kucoin.com/referral/your-link' }}
          REF_BYBIT: ${{ vars.REF_BYBIT || 'https://www.bybit.com/referral/your-link' }}
          REF_OKX: ${{ vars.REF_OKX || 'https://www.okx.com/referral/your-link' }}
          AFFILIATE_MAP: ${{ vars.AFFILIATE_MAP }}
          SITE_TITLE: ${{ vars.SITE_TITLE || 'InfinityBot - Web3 Eternity Hub' }}
          SITE_DESC: ${{ vars.SITE_DESC || 'Earn instantly with crypto airdrops, NFTs, DeFi, affiliates, memecoins, Web3 gaming, SocialFi, prediction markets, crowdfunding, tokenized assets, RWA, DAOs on infinitybot.op' }}
          SITE_BASE: ${{ vars.SITE_BASE || 'https://infinitybot.op' }}
          CONTRACT_ADDRESS: $(cat contract-addresses.txt 2>/dev/null | grep Polygon_0 | cut -d' ' -f2 || echo "0xYourSmartContractAddress")
          GOOGLE_TRANSLATE_API_KEY: ${{ secrets.GOOGLE_TRANSLATE_API_KEY }}
          DEEPL_API_KEY: ${{ secrets.DEEPL_API_KEY }}
          NOSTR_PRIVATE_KEY: ${{ secrets.NOSTR_PRIVATE_KEY }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import QRCode from 'qrcode'
          import { Relay, generatePrivateKey, getPublicKey, signEvent } from 'nostr-tools'
          const items = JSON.parse(fs.readFileSync('data/opps.scored.json', 'utf8'))
          let map = {}
          try { map = JSON.parse(process.env.AFFILIATE_MAP || '{}') } catch {}
          if (process.env.REF_BINANCE) map['binance'] = process.env.REF_BINANCE
          if (process.env.REF_ALGOSONE) map['algosone'] = process.env.REF_ALGOSONE
          if (process.env.REF_COINBASE) map['coinbase'] = process.env.REF_COINBASE
          if (process.env.REF_KUCOIN) map['kucoin'] = process.env.REF_KUCOIN
          if (process.env.REF_BYBIT) map['bybit'] = process.env.REF_BYBIT
          if (process.env.REF_OKX) map['okx'] = process.env.REF_OKX
          const title = process.env.SITE_TITLE
          const desc = process.env.SITE_DESC
          const base = process.env.SITE_BASE || 'https://infinitybot.op'
          const contract = process.env.CONTRACT_ADDRESS
          const languages = ['en', 'vi', 'zh', 'ja', 'ko', 'es', 'fr', 'de', 'ru', 'pt', 'it', 'ar', 'th', 'id', 'ms', 'hi', 'tr', 'bn', 'pa', 'ur', 'nl', 'pl', 'sv', 'no', 'da', 'fi', 'he', 'el', 'cs', 'hu', 'ro', 'sk', 'uk', 'bg', 'hr', 'sl', 'et', 'lv', 'lt', 'ml', 'ta', 'te', 'kn', 'mr', 'gu', 'or', 'as', 'si']
          const payList = [
            ['MoMo', process.env.PAYMENT_MOMO],
            ['Vietcombank', process.env.PAYMENT_VCB],
            ['USDT (ERC20)', process.env.PAYMENT_USDT_ERC20],
            ['ETH', process.env.PAYMENT_ETH],
            ['BTC', process.env.PAYMENT_BTC],
            ['PayPal', process.env.PAYMENT_PAYPAL],
            ['Binance Referral', process.env.REF_BINANCE],
            ['AlgosOne Referral', process.env.REF_ALGOSONE],
            ['Coinbase Referral', process.env.REF_COINBASE],
            ['KuCoin Referral', process.env.REF_KUCOIN],
            ['Bybit Referral', process.env.REF_BYBIT],
            ['OKX Referral', process.env.REF_OKX]
          ].filter(([, v]) => v)
          async function makeQR(text) { try { return await QRCode.toDataURL(text) } catch { return '' } }
          const pays = []
          for (const [k, v] of payList) { pays.push([k, v, await makeQR(`${k}: ${v}`)]) }
          const pick = (text, fallback) => {
            const t = (text || '').toLowerCase()
            for (const [k, v] of Object.entries(map)) {
              if (t.includes(k.toLowerCase())) return v || fallback
            }
            return fallback
          }
          const listHtml = (items || []).slice(0, 10000).map(it => {
            const link = pick((it.title || '') + ' ' + (it.description || '') + ' ' + (it.src || ''), it.link || '#')
            return `<div class="card"><a class="out cta-button" href="${link}" target="_blank" rel="noopener">${it.title || 'Opportunity'}</a><div class="meta">${it.src || ''} • ${it.date || ''} • Score: ${it.score.toFixed(4)}</div><button class="cta">Claim Now!</button></div>`
          }).join('') || '<p>No data yet. Add RSS sources.</p>'
          const paysHtml = pays.map(([k, v, qr]) => `
            <div class="p"><strong>${k}</strong>: ${k.includes('Referral') ? `<a href="${v}" target="_blank">${v}</a>` : k === 'PayPal' ? `<a href="mailto:${v}">${v}</a>` : `<code>${v}</code>`}
              ${qr ? `<div><img alt="${k} QR" src="${qr}" style="height:120px"></div>` : ''}
              <button onclick="navigator.clipboard.writeText('${v}')">Copy</button>
            </div>`).join('') || '<div>Not configured</div>'
          const html = `<!doctype html><html lang="en"><head><meta charset="utf-8">
            <meta name="viewport" content="width=device-width,initial-scale=1">
            <title>${title}</title><meta name="description" content="${desc}">
            <meta name="keywords" content="crypto, airdrop, affiliate, referral, NFT, DeFi, staking, memecoin, Web3 gaming, SocialFi, prediction markets, crowdfunding, tokenized assets, RWA, DAOs, yield farming, liquidity mining, play-to-earn, vote-to-earn, earn crypto, blockchain, metaverse, infinitybot">
            <meta property="og:title" content="${title}"/><meta property="og:description" content="${desc}"/>
            <meta property="og:image" content="${base}/og-image.jpg"/>
            <link rel="manifest" href="/manifest.json">
            <script src="https://cdn.jsdelivr.net/npm/web3modal@2.4.1/dist/index.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/@xai/grok-sdk@0.1.0/dist/grok.min.js"></script>
            <script src="https://apis.google.com/js/api.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/deepl@1.0.0/dist/deepl.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/nostr-tools@1.7.5/lib/nostr.bundle.min.js"></script>
            <style>
              body { font-family: system-ui, Arial, sans-serif; margin: 0; line-height: 1.55; background: #f7f9fc; color: #333 }
              .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; padding: 20px }
              .card { border: 1px solid #e6e9ef; border-radius: 12px; padding: 14px; background: #fff; transition: transform 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1) }
              .card:hover { transform: scale(1.02) }
              .cta-button { color: #0b61ff; text-decoration: none; font-weight: bold }
              .cta { background: linear-gradient(45deg, #0b61ff, #ffd700); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; margin-top: 10px }
              .p { margin: 10px 0 }
              code { background: #f1f3f7; padding: 2px 6px; border-radius: 6px }
              a { color: #0b61ff; text-decoration: none }
              button { margin-top: 6px; padding: 6px 10px; border: 1px solid #d0d7e2; border-radius: 8px; background: #fff; cursor: pointer }
              footer { margin: 20px; text-align: center }
              #metaverse { width: 100%; height: 400px; background: linear-gradient(45deg, #0b61ff, #ffd
