name: ai-omnibot-v10-transcendent

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      mode:
        description: "Run mode"
        type: choice
        default: full_cycle
        options: [full_cycle]
      rss_urls:
        description: "CSV RSS URLs (override)"
        required: false
      seed_urls:
        description: "CSV seed websites to discover RSS (override)"
        required: false
      trade_mode:
        description: "paper or live (live needs webhook)"
        default: "paper"
      confidence_threshold:
        description: "LLM score threshold 0..1 for LIVE actions"
        default: "0.85"
  schedule:
    - cron: "*/8 * * * *"  # Run every 8 minutes

permissions:
  contents: write
  issues: write
  pull-requests: write
  models: read
  actions: write

concurrency:
  group: ai-omnibot-v10-transcendent-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: false

jobs:
  setup-check:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-configure environment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          KILL_SWITCH: ${{ secrets.KILL_SWITCH }}
          PINATA_API_KEY: ${{ secrets.PINATA_API_KEY }}
          PINATA_API_SECRET: ${{ secrets.PINATA_API_SECRET }}
          FLEEK_API_KEY: ${{ secrets.FLEEK_API_KEY }}
        run: |
          echo "## Configuration Setup" >> $GITHUB_STEP_SUMMARY
          if [ -z "$KILL_SWITCH" ]; then
            curl -s -X PUT \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -d '{"encrypted_value":"T05F"}' \
              "https://api.github.com/repos/${{ github.repository }}/actions/secrets/KILL_SWITCH"
            echo "Set KILL_SWITCH=ON" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -z "$PINATA_API_KEY" ] || [ -z "$PINATA_API_SECRET" ]; then
            echo "No Pinata credentials -> auto-registering" >> $GITHUB_STEP_SUMMARY
            node --input-type=module - <<'NODE'
            import fetch from 'node-fetch'
            async function registerIPFS() {
              try {
                let apiKey, apiSecret
                // Try Pinata
                const pinataRes = await fetch('https://api.pinata.cloud/users/register', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ email: `temp-${Date.now()}@example.com`, password: 'TempPass123!' })
                })
                const pinataData = await pinataRes.json()
                if (pinataData.apiKey && pinataData.apiSecret) {
                  apiKey = pinataData.apiKey
                  apiSecret = pinataData.apiSecret
                  await fetch('https://api.github.com/repos/${{ github.repository }}/actions/secrets/PINATA_API_KEY', {
                    method: 'PUT',
                    headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                    body: JSON.stringify({ encrypted_value: apiKey })
                  })
                  await fetch('https://api.github.com/repos/${{ github.repository }}/actions/secrets/PINATA_API_SECRET', {
                    method: 'PUT',
                    headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                    body: JSON.stringify({ encrypted_value: apiSecret })
                  })
                  console.log('Auto-registered Pinata API key')
                } else {
                  // Fallback to Fleek
                  const fleekRes = await fetch('https://api.fleek.co/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: `temp-${Date.now()}@fleek.co`, password: 'TempPass123!' })
                  })
                  const fleekData = await fleekRes.json()
                  if (fleekData.apiKey) {
                    await fetch('https://api.github.com/repos/${{ github.repository }}/actions/secrets/FLEEK_API_KEY', {
                      method: 'PUT',
                      headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                      body: JSON.stringify({ encrypted_value: fleekData.apiKey })
                    })
                    console.log('Auto-registered Fleek API key')
                  } else {
                    // Fallback to Filecoin (Web3.Storage)
                    const filecoinRes = await fetch('https://api.web3.storage/register', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ email: `temp-${Date.now()}@web3.storage`, password: 'TempPass123!' })
                    })
                    const filecoinData = await filecoinRes.json()
                    if (filecoinData.apiKey) {
                      await fetch('https://api.github.com/repos/${{ github.repository }}/actions/secrets/WEB3_STORAGE_API_KEY', {
                        method: 'PUT',
                        headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
                        body: JSON.stringify({ encrypted_value: filecoinData.apiKey })
                      })
                      console.log('Auto-registered Web3.Storage API key')
                    }
                  }
                }
              } catch (e) { console.log('IPFS registration error:', e.message) }
            }
            registerIPFS()
            NODE
          else
            echo "✅ IPFS credentials set" >> $GITHUB_STEP_SUMMARY
          fi
          echo "Generating temporary wallet for OPNS" >> $GITHUB_STEP_SUMMARY
          node --input-type=module - <<'NODE'
          import Web3 from 'web3'
          const web3 = new Web3()
          const account = web3.eth.accounts.create()
          await fetch('https://api.github.com/repos/${{ github.repository }}/actions/secrets/TEMP_WALLET_PRIVATE_KEY', {
            method: 'PUT',
            headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
            body: JSON.stringify({ encrypted_value: account.privateKey })
          })
          await fetch('https://api.github.com/repos/${{ github.repository }}/actions/secrets/TEMP_WALLET_ADDRESS', {
            method: 'PUT',
            headers: { 'Authorization': `Bearer ${{ secrets.GITHUB_TOKEN }}`, 'Accept': 'application/vnd.github+json' },
            body: JSON.stringify({ encrypted_value: account.address })
          })
          console.log('Generated temporary wallet:', account.address)
          NODE

  run:
    runs-on: ubuntu-latest
    needs: setup-check
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          npm i rss-parser@3 node-fetch@3 cheerio@1 qrcode@1 @pinata/sdk@2 @fleekhq/fleek-sdk@1 web3@1 @web3-storage/client@1

      # ================== AGENT: DEPLOY SMART CONTRACT ==================
      - name: Deploy Smart Contract
        env:
          TEMP_WALLET_PRIVATE_KEY: ${{ secrets.TEMP_WALLET_PRIVATE_KEY }}
          TEMP_WALLET_ADDRESS: ${{ secrets.TEMP_WALLET_ADDRESS }}
        run: |
          node --input-type=module - <<'NODE'
          import Web3 from 'web3'
          import fs from 'fs'
          const web3 = new Web3('https://rpc-mainnet.maticvigil.com') // Polygon mainnet
          const account = web3.eth.accounts.privateKeyToAccount(process.env.TEMP_WALLET_PRIVATE_KEY)
          web3.eth.accounts.wallet.add(account)
          const contractABI = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"donor","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"string","name":"currency","type":"string"}],"name":"Donated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"NFTMinted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"subscriber","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"string","name":"currency","type":"string"}],"name":"Subscribed","type":"event"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"currency","type":"string"}],"name":"donate","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"mintNFT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"currency","type":"string"}],"name":"subscribe","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"subscribers","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalDonations","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSubscriptions","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}]
          const contractBytecode = "0x608060405234801561001057600080fd5b506102c3806100206000396000f3fe60806040526004361061004e5760003560e01c80633ccfd60b146100575780638da5cb5b1461006e578063a6f9dae11461009f578063d0e30db0146100bf578063f10fdf5c146100d7578063f2b1b8821461010a57610055565b3661005557005b600080fd5b34801561006357600080fd5b5061006c61012a565b005b34801561007a57600080fd5b50600054610087906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b3480156100ab57600080fd5b5061006c6100ba36600461024c565b61013e565b6100d56100d536600461026e565b61015e565b005b3480156100e357600080fd5b506100f76100f2366004610290565b6101b0565b60405190815260200160405180910390f35b34801561011657600080fd5b5061012060015481565b6040519081526020016100f7565b6000546001600160a01b0316331461013d57600080fd5b005b6000546001600160a01b0316331461015557600080fd5b61013d6101e8565b6040516323b872dd60e01b81523360048201523060248201526044820181905260009081906064906000856001600160a01b03168663a9059cbb60e01b9060840160408051601f198184030181529181526020820180516001600160e01b031663a9059cbb60e01b1790528151600094859450909250871692506101e49150829060240190565b60405180910390a150565b600080546040516001600160a01b0390911690600081818185875af1925050503d8060008114610237576040519150601f19603f3d011682016040523d82523d6000602084013e61023c565b606091505b50509050565b60006020828403121561025e57600080fd5b81356001600160a01b03169050919050565b6000806040838503121561028157600080fd5b50508035936020909101359150565b6000602082840312156102a257600080fd5b503591905056"
          async function deployContract() {
            try {
              const contract = new web3.eth.Contract(contractABI)
              const deployTx = contract.deploy({ data: contractBytecode })
              const gas = await deployTx.estimateGas({ from: account.address })
              const tx = await deployTx.send({ from: account.address, gas })
              fs.writeFileSync('contract-address.txt', tx.options.address)
              // Transfer funds to user's wallets
              const userWallets = ['0x5da80d0f7e2df3cb0aa73d6a942bbe36b046b8f0', '0x54E15A7b6d4213beE87800432A151d794638E3C2']
              for (const wallet of userWallets) {
                await web3.eth.sendTransaction({ from: account.address, to: wallet, value: web3.utils.toWei('0.001', 'ether') })
              }
              console.log('Contract deployed:', tx.options.address)
            } catch (e) { console.error('Contract deploy error:', e.message) }
          }
          deployContract()
          NODE

      # ================== AGENT: CRAWLER ==================
      - name: Agent: Crawler
        env:
          SEED_URLS: ${{ inputs.seed_urls || 'https://coindesk.com,https://cointelegraph.com,https://airdropalert.com,https://bitcointalk.org,https://reddit.com/r/cryptocurrency,https://news.bitcoin.com,https://theblock.co,https://producthunt.com,https://techcrunch.com,https://defillama.com,https://farcaster.network,https://lens.xyz' }}
          EXTRA_RSS: ${{ inputs.rss_urls || 'https://coindesk.com/feed,https://cointelegraph.com/rss,https://airdropalert.com/feed,https://news.bitcoin.com/feed' }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          const fetch = (await import('node-fetch')).default
          const cheerio = (await import('cheerio')).default
          const seeds = (process.env.SEED_URLS || '').split(',').map(s => s.trim()).filter(Boolean)
          const extras = (process.env.EXTRA_RSS || '').split(',').map(s => s.trim()).filter(Boolean)
          const out = new Set(extras)
          for (const url of seeds) {
            try {
              const res = await fetch(url, { timeout: 15000 })
              const html = await res.text()
              const $ = cheerio.load(html)
              $('link[rel="alternate"]').each((_, el) => {
                const type = ($(el).attr('type') || '').toLowerCase()
                const href = $(el).attr('href')
                if (href && (type.includes('rss') || type.includes('atom') || href.endsWith('.xml'))) {
                  let u = href
                  if (u.startsWith('/')) { try { const b = new URL(url); u = b.origin + u } catch {} }
                  out.add(u)
                }
              })
              const sm = url.replace(/\/+$/, '') + '/sitemap.xml'
              out.add(sm)
            } catch (e) { console.log('Seed error', url, e.message) }
          }
          const feeds = [...out].filter(u => /(\.xml|feed|rss|atom)/i.test(u))
          fs.mkdirSync('data', { recursive: true })
          fs.writeFileSync('data/feeds.txt', feeds.join('\n') + '\n')
          console.log('Discovered feeds:', feeds.length)
          NODE

      # ================== AGENT: INGEST ==================
      - name: Agent: Ingest
        env:
          FEEDS_FILE: data/feeds.txt
          RSS_URLS: ${{ inputs.rss_urls || 'https://coindesk.com/feed,https://cointelegraph.com/rss,https://airdropalert.com/feed,https://news.bitcoin.com/feed' }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import Parser from 'rss-parser'
          const parser = new Parser()
          async function fetchWithRetry(url, retries = 5) {
            for (let i = 0; i < retries; i++) {
              try {
                const res = await parser.parseURL(url)
                return res
              } catch (e) {
                if (i === retries - 1) console.log('RSS error', url, e.message)
                await new Promise(resolve => setTimeout(resolve, 1000))
              }
            }
            return null
          }
          let feeds = []
          try {
            feeds = (fs.existsSync(process.env.FEEDS_FILE) ? fs.readFileSync(process.env.FEEDS_FILE, 'utf8') : '')
              .split('\n').map(s => s.trim()).filter(Boolean)
          } catch {}
          const extra = (process.env.RSS_URLS || '').split(',').map(s => s.trim()).filter(Boolean)
          const all = [...new Set([...feeds, ...extra])]
          let items = []
          for (const url of all) {
            const feed = await fetchWithRetry(url)
            if (feed) {
              for (const it of (feed.items || [])) {
                items.push({
                  type: 'rss',
                  title: it.title || '',
                  link: it.link || '#',
                  date: it.isoDate || it.pubDate || '',
                  src: url,
                  description: it.contentSnippet || it.description || ''
                })
              }
            }
          }
          items = items.filter(x => x.title && x.link !== '#')
          fs.mkdirSync('data', { recursive: true })
          fs.writeFileSync('data/opps.raw.json', JSON.stringify(items, null, 2))
          console.log('Ingested items:', items.length)
          NODE

      # ================== AGENT: SCORER ==================
      - name: Agent: Scorer
        env:
          LLM_API_URL: ${{ vars.LLM_API_URL || 'https://api.x.ai/v1/chat/completions' }}
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          LLM_MODEL: ${{ vars.LLM_MODEL || 'grok-3' }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          const fetch = (await import('node-fetch')).default
          const raw = 'data/opps.raw.json'
          const items = fs.existsSync(raw) ? JSON.parse(fs.readFileSync(raw, 'utf8')) : []
          async function llmScore(arr) {
            const url = process.env.LLM_API_URL, key = process.env.LLM_API_KEY
            if (!url || !key) {
              console.log('No LLM credentials, falling back to keyword scoring')
              return null
            }
            try {
              const prompt = `Score each item 0..1 for monetization potential (airdrop, affiliate, referral, high yield, exclusive offer, trading opportunity, NFT, DeFi, staking, trending on X/Farcaster/Lens). Return a JSON array of numbers with length=${arr.length}. Items:\n` + arr.map((x, i) => `${i+1}. ${x.title} (${x.description})`).join('\n')
              const body = {
                model: process.env.LLM_MODEL || 'grok-3',
                messages: [
                  { role: 'system', content: 'Output only a JSON array of numbers 0..1.' },
                  { role: 'user', content: prompt }
                ]
              }
              const res = await fetch(url, {
                method: 'POST',
                headers: { 'content-type': 'application/json', 'authorization': `Bearer ${key}` },
                body: JSON.stringify(body)
              })
              const j = await res.json()
              const txt = j.choices?.[0]?.message?.content || ''
              const nums = JSON.parse(txt.match(/\[.*\]/s)?.[0] || '[]')
              return Array.isArray(nums) && nums.length === arr.length ? nums : null
            } catch (e) {
              console.log('LLM scoring failed:', e.message)
              return null
            }
          }
          let scored = []
          const sample = items.slice(0, 100)
          const nums = await llmScore(sample)
          if (nums) {
            scored = sample.map((it, i) => ({ ...it, score: Number(nums[i] || 0) })).sort((a, b) => b.score - a.score)
          } else {
            const weights = {
              'free crypto': 0.95, 'high yield': 0.9, 'exclusive offer': 0.9,
              'airdrop': 0.85, 'referral': 0.85, 'affiliate': 0.85, 'bounty': 0.85,
              'nft': 0.9, 'defi': 0.9, 'staking': 0.9,
              'binance': 0.8, 'algosone': 0.8, 'algorand': 0.8, 'coinbase': 0.8, 'kucoin': 0.8, 'bybit': 0.8,
              'trending': 0.95, 'farcaster': 0.9, 'lens': 0.9
            }
            scored = items.map(it => {
              const text = ((it.title || '') + ' ' + (it.description || '') + ' ' + (it.src || '')).toLowerCase()
              let score = 0
              for (const [key, weight] of Object.entries(weights)) {
                if (text.includes(key)) score = Math.max(score, weight)
              }
              return { ...it, score }
            }).filter(x => x.score > 0).sort((a, b) => b.score - a.score)
          }
          fs.mkdirSync('data', { recursive: true })
          fs.writeFileSync('data/opps.scored.json', JSON.stringify(scored, null, 2))
          console.log('Scored items:', scored.length)
          NODE

      # ================== AGENT: AFFILIATE ==================
      - name: Agent: Affiliate Map
        env:
          REF_BINANCE: "https://www.binance.com/referral/earn-together/refer-in-hotsummer/claim?hl=vi&ref=GRO_20338_9V44N&utm_source=lightunfold&utm_campaign=v10"
          REF_ALGOSONE: "https://algosone.page.link/MbtR?utm_source=lightunfold&utm_campaign=v10"
          REF_COINBASE: ${{ vars.REF_COINBASE || 'https://www.coinbase.com/referral/your-link' }}
          REF_KUCOIN: ${{ vars.REF_KUCOIN || 'https://www.kucoin.com/referral/your-link' }}
          REF_BYBIT: ${{ vars.REF_BYBIT || 'https://www.bybit.com/referral/your-link' }}
          AFFILIATE_MAP: ${{ vars.AFFILIATE_MAP }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          const p = 'data/opps.scored.json'
          const items = fs.existsSync(p) ? JSON.parse(fs.readFileSync(p, 'utf8')) : []
          let map = {}
          try { map = JSON.parse(process.env.AFFILIATE_MAP || '{}') } catch {}
          if (process.env.REF_BINANCE) map['binance'] = process.env.REF_BINANCE
          if (process.env.REF_ALGOSONE) map['algosone'] = process.env.REF_ALGOSONE
          if (process.env.REF_COINBASE) map['coinbase'] = process.env.REF_COINBASE
          if (process.env.REF_KUCOIN) map['kucoin'] = process.env.REF_KUCOIN
          if (process.env.REF_BYBIT) map['bybit'] = process.env.REF_BYBIT
          const brands = new Set()
          for (const it of items) {
            const t = ((it.title || '') + ' ' + (it.description || '')).toLowerCase()
            if (/binance|bnb/.test(t) && !map['binance']) brands.add('binance')
            if (/algosone|algorand|algo/.test(t) && !map['algosone']) brands.add('algosone')
            if (/coinbase/.test(t) && !map['coinbase']) brands.add('coinbase')
            if (/kucoin/.test(t) && !map['kucoin']) brands.add('kucoin')
            if (/bybit/.test(t) && !map['bybit']) brands.add('bybit')
          }
          if (brands.size) {
            console.log('Affiliate suggestions:', [...brands].join(', '))
            fs.writeFileSync('data/affiliate.suggest.txt', [...brands].join('\n') + '\n')
          }
          fs.writeFileSync('data/affiliate.map.json', JSON.stringify(map, null, 2))
          NODE

      # ================== AGENT: SITE ==================
      - name: Agent: Site Builder
        env:
          PAYMENT_MOMO: "0567892030"
          PAYMENT_VCB: "9567892030"
          PAYMENT_USDT_ERC20: "0x5da80d0f7e2df3cb0aa73d6a942bbe36b046b8f0"
          PAYMENT_ETH: "0x54E15A7b6d4213beE87800432A151d794638E3C2"
          PAYMENT_BTC: $(node -e "const Web3 = require('web3'); console.log(new Web3().eth.accounts.create().address)")
          PAYMENT_PAYPAL: "vumumabada@gmail.com"
          REF_BINANCE: "https://www.binance.com/referral/earn-together/refer-in-hotsummer/claim?hl=vi&ref=GRO_20338_9V44N&utm_source=lightunfold&utm_campaign=v10"
          REF_ALGOSONE: "https://algosone.page.link/MbtR?utm_source=lightunfold&utm_campaign=v10"
          REF_COINBASE: ${{ vars.REF_COINBASE || 'https://www.coinbase.com/referral/your-link' }}
          REF_KUCOIN: ${{ vars.REF_KUCOIN || 'https://www.kucoin.com/referral/your-link' }}
          REF_BYBIT: ${{ vars.REF_BYBIT || 'https://www.bybit.com/referral/your-link' }}
          AFFILIATE_MAP: ${{ vars.AFFILIATE_MAP }}
          SITE_TITLE: ${{ vars.SITE_TITLE || 'Light Unfold - Transcendent Web3 Hub' }}
          SITE_DESC: ${{ vars.SITE_DESC || 'Earn with crypto airdrops, NFTs, DeFi, affiliates, and more on lightunfold.op' }}
          SITE_BASE: ${{ vars.SITE_BASE || 'https://lightunfold.op' }}
          CONTRACT_ADDRESS: $(cat contract-address.txt 2>/dev/null || echo "0xYourSmartContractAddress")
          TEMP_WALLET_ADDRESS: ${{ secrets.TEMP_WALLET_ADDRESS }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import QRCode from 'qrcode'
          const items = JSON.parse(fs.readFileSync('data/opps.scored.json', 'utf8'))
          let map = {}
          try { map = JSON.parse(process.env.AFFILIATE_MAP || '{}') } catch {}
          if (process.env.REF_BINANCE) map['binance'] = process.env.REF_BINANCE
          if (process.env.REF_ALGOSONE) map['algosone'] = process.env.REF_ALGOSONE
          if (process.env.REF_COINBASE) map['coinbase'] = process.env.REF_COINBASE
          if (process.env.REF_KUCOIN) map['kucoin'] = process.env.REF_KUCOIN
          if (process.env.REF_BYBIT) map['bybit'] = process.env.REF_BYBIT
          const title = process.env.SITE_TITLE
          const desc = process.env.SITE_DESC
          const base = process.env.SITE_BASE || 'https://lightunfold.op'
          const contract = process.env.CONTRACT_ADDRESS
          const tempWallet = process.env.TEMP_WALLET_ADDRESS
          const payList = [
            ['MoMo', process.env.PAYMENT_MOMO],
            ['Vietcombank', process.env.PAYMENT_VCB],
            ['USDT (ERC20)', process.env.PAYMENT_USDT_ERC20],
            ['ETH', process.env.PAYMENT_ETH],
            ['BTC', process.env.PAYMENT_BTC],
            ['PayPal', process.env.PAYMENT_PAYPAL],
            ['Binance Referral', process.env.REF_BINANCE],
            ['AlgosOne Referral', process.env.REF_ALGOSONE],
            ['Coinbase Referral', process.env.REF_COINBASE],
            ['KuCoin Referral', process.env.REF_KUCOIN],
            ['Bybit Referral', process.env.REF_BYBIT]
          ].filter(([, v]) => v)
          async function makeQR(text) { try { return await QRCode.toDataURL(text) } catch { return '' } }
          const pays = []
          for (const [k, v] of payList) { pays.push([k, v, await makeQR(`${k}: ${v}`)]) }
          const pick = (text, fallback) => {
            const t = (text || '').toLowerCase()
            for (const [k, v] of Object.entries(map)) {
              if (t.includes(k.toLowerCase())) return v || fallback
            }
            if (/binance|bnb/.test(t) && map['binance']) return map['binance']
            if (/algosone|algorand|algo/.test(t) && map['algosone']) return map['algosone']
            if (/coinbase/.test(t) && map['coinbase']) return map['coinbase']
            if (/kucoin/.test(t) && map['kucoin']) return map['kucoin']
            if (/bybit/.test(t) && map['bybit']) return map['bybit']
            return fallback
          }
          const listHtml = (items || []).slice(0, 100).map(it => {
            const link = pick((it.title || '') + ' ' + (it.description || '') + ' ' + (it.src || ''), it.link || '#')
            return `<div class="card"><a class="out cta-button" href="${link}" target="_blank" rel="noopener">${it.title || 'Opportunity'}</a><div class="meta">${it.src || ''} • ${it.date || ''}</div><button class="cta">Claim Now!</button></div>`
          }).join('') || '<p>No data yet. Add RSS sources.</p>'
          const paysHtml = pays.map(([k, v, qr]) => `
            <div class="p"><strong>${k}</strong>: ${k.includes('Referral') ? `<a href="${v}" target="_blank">${v}</a>` : k === 'PayPal' ? `<a href="mailto:${v}">${v}</a>` : `<code>${v}</code>`}
              ${qr ? `<div><img alt="${k} QR" src="${qr}" style="height:120px"></div>` : ''}
              <button onclick="navigator.clipboard.writeText('${v}')">Copy</button>
            </div>`).join('') || '<div>Not configured</div>'
          const html = `<!doctype html><html lang="en"><head><meta charset="utf-8">
            <meta name="viewport" content="width=device-width,initial-scale=1">
            <title>${title}</title><meta name="description" content="${desc}">
            <meta name="keywords" content="crypto, airdrop, affiliate, referral, NFT, DeFi, staking, earn money, blockchain, lightunfold, metaverse">
            <meta property="og:title" content="${title}"/><meta property="og:description" content="${desc}"/>
            <meta property="og:image" content="${base}/og-image.jpg"/>
            <script src="https://cdn.jsdelivr.net/npm/web3modal@2.4.1/dist/index.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/@xai/grok-sdk@0.1.0/dist/grok.min.js"></script>
            <style>
              body { font-family: system-ui, Arial, sans-serif; margin: 0; line-height: 1.55; background: #f7f9fc }
              .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; padding: 20px }
              .card { border: 1px solid #e6e9ef; border-radius: 12px; padding: 14px; background: #fff; transition: transform 0.2s }
              .card:hover { transform: scale(1.02) }
              .cta-button { color: #0b61ff; text-decoration: none; font-weight: bold }
              .cta { background: #0b61ff; color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; margin-top: 10px }
              .p { margin: 10px 0 }
              code { background: #f1f3f7; padding: 2px 6px; border-radius: 6px }
              a { color: #0b61ff; text-decoration: none }
              button { margin-top: 6px; padding: 6px 10px; border: 1px solid #d0d7e2; border-radius: 8px; background: #fff; cursor: pointer }
              footer { margin: 20px; text-align: center }
              #metaverse { width: 100%; height: 400px }
              #chatbot { position: fixed; bottom: 20px; right: 20px; background: #fff; border: 1px solid #e6e9ef; padding: 10px; border-radius: 8px }
            </style></head><body>
              <div id="metaverse"></div>
              <h1>${title}</h1><p>${desc}</p>
              <div class="box"><h3>Support Us / Join Now</h3>
                <button onclick="connectWallet()">Connect Wallet (USDT/ETH/BTC)</button>
                <button onclick="mintNFT()">Mint Your NFT</button>
                <button onclick="stake()">Stake USDT/ETH</button>
                <button onclick="joinAirdrop()">Join Airdrop</button>
                ${paysHtml}
              </div>
              <h2 style="margin:20px">Top Crypto, NFT & DeFi Opportunities</h2>
              <div class="grid">${listHtml}</div>
              <div id="chatbot">
                <input id="chatInput" placeholder="Ask about crypto, NFTs, DeFi...">
                <button onclick="chat()">Send</button>
                <div id="chatOutput"></div>
              </div>
              <footer><hr/><small>Powered by AI Omnibot v10 on lightunfold.op — Web2↔Web3. Not financial advice.</small> ·
                <a href="${base}/sitemap.xml">Sitemap</a> · <a href="${base}/feed.xml">RSS</a> · <a href="https://lens.xyz/lightunfold">Lens</a> · <a href="https://farcaster.network/lightunfold">Farcaster</a></footer>
              <script>
                const providerOptions = {
                  walletconnect: { package: window.WalletConnectProvider, options: { rpc: { 137: 'https://rpc-mainnet.maticvigil.com', 1: 'https://mainnet.infura.io/v3/free', 42161: 'https://arb1.arbitrum.io/rpc' } } },
                  coinbasewallet: { package: window.CoinbaseWalletSDK, options: { appName: 'Light Unfold', rpc: 'https://rpc-mainnet.maticvigil.com' } }
                };
                const web3Modal = new Web3Modal.default({ providerOptions });
                async function connectWallet() {
                  try {
                    const provider = await web3Modal.connect();
                    const ethersProvider = new ethers.providers.Web3Provider(provider);
                    const signer = ethersProvider.getSigner();
                    const contract = new ethers.Contract('${contract}', [
                      'function donate(uint256 amount, string currency) payable',
                      'function subscribe(uint256 amount, string currency) payable',
                      'function mintNFT(address to) public returns (uint256)'
                    ], signer);
                    const currency = prompt('Select currency (USDT/ETH/BTC):')?.toUpperCase() || 'USDT';
                    const amount = currency === 'BTC' ? '0' : ethers.utils.parseUnits('5', 6);
                    const value = currency === 'ETH' ? ethers.utils.parseEther('0.001') : '0';
                    const tx = await contract.donate(amount, currency, { value });
                    await tx.wait();
                    alert('Donation successful! Funds sent to ${tempWallet}');
                  } catch (e) { alert('Error: ' + e.message); }
                }
                async function mintNFT() {
                  try {
                    const provider = await web3Modal.connect();
                    const ethersProvider = new ethers.providers.Web3Provider(provider);
                    const signer = ethersProvider.getSigner();
                    const contract = new ethers.Contract('${contract}', [
                      'function mintNFT(address to) public returns (uint256)'
                    ], signer);
                    const tx = await contract.mintNFT(await signer.getAddress(), { value: ethers.utils.parseEther('0.001') });
                    await tx.wait();
                    alert('NFT minted successfully!');
                  } catch (e) { alert('Error: ' + e.message); }
                }
                async function stake() {
                  try {
                    const provider = await web3Modal.connect();
                    const ethersProvider = new ethers.providers.Web3Provider(provider);
                    const signer = ethersProvider.getSigner();
                    alert('Redirecting to Aave/PancakeSwap for staking...');
                    window.location.href = 'https://app.aave.com';
                  } catch (e) { alert('Error: ' + e.message); }
                }
                async function joinAirdrop() {
                  window.location.href = 'https://airdropalert.com/latest';
                }
                async function chat() {
                  const input = document.getElementById('chatInput').value;
                  const output = document.getElementById('chatOutput');
                  try {
                    const grok = new Grok({ apiKey: 'free-tier' });
                    const res = await grok.chat({ prompt: input, context: 'Crypto, NFT, DeFi opportunities' });
                    output.innerHTML = res.response || 'Try again!';
                  } catch (e) { output.innerHTML = 'Chat error: ' + e.message; }
                }
                // Metaverse 3D background
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / 400, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('metaverse') });
                renderer.setSize(window.innerWidth, 400);
                const geometry = new THREE.SphereGeometry(5, 32, 32);
                const material = new THREE.MeshBasicMaterial({ color: 0x0b61ff, wireframe: true });
                const sphere = new THREE.Mesh(geometry, material);
                scene.add(sphere);
                camera.position.z = 10;
                function animate() { requestAnimationFrame(animate); sphere.rotation.y += 0.01; renderer.render(scene, camera); }
                animate();
              </script>
            </body></html>`
          fs.writeFileSync('index.html', html)
          const blogPost = `---
title: Top Crypto, NFT & DeFi Opportunities in 2025
description: Discover the best crypto airdrops, NFTs, DeFi, and affiliates on lightunfold.op.
keywords: crypto airdrop, NFT, DeFi, staking, referral, affiliate, earn crypto, blockchain, metaverse
---
# Top Crypto, NFT & DeFi Opportunities in 2025
${items.slice(0, 5).map(it => `- [${it.title}](${pick((it.title || '') + ' ' + (it.description || '') + ' ' + (it.src || ''), it.link || '#')}): ${it.src} (${it.date})`).join('\n')}
\nJoin now on [lightunfold.op](${base}) or [RSS feed](${base}/feed.xml) to start earning!`
          fs.mkdirSync('blog', { recursive: true })
          fs.writeFileSync('blog/opportunities-2025.md', blogPost)
          const premiumHtml = `<!doctype html><html lang="en"><head><meta charset="utf-8">
            <meta name="viewport" content="width=device-width,initial-scale=1">
            <title>Premium Web3 Opportunities</title><meta name="description" content="Unlock exclusive crypto, NFT, and DeFi opportunities on lightunfold.op">
            <script src="https://cdn.jsdelivr.net/npm/web3modal@2.4.1/dist/index.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
            <style>${fs.readFileSync('index.html').toString().match(/<style>.*<\/style>/s)[0]}</style></head><body>
              <h1>Premium Web3 Opportunities</h1>
              <p>Unlock exclusive airdrops, NFTs, DeFi staking, and trading signals for $5-$50/month via USDT/ETH/BTC.</p>
              <button onclick="subscribe()">Subscribe with USDT/ETH/BTC</button>
              <a href="https://coinpayments.net/your-payment-link">Subscribe with PayPal</a>
              <div class="box"><h3>Support Us</h3>${paysHtml}</div>
              <footer><hr/><small>Powered by AI Omnibot v10 on lightunfold.op — Web2↔Web3. Not financial advice.</small></footer>
              <script>
                const providerOptions = { walletconnect: { package: window.WalletConnectProvider, options: { rpc: { 137: 'https://rpc-mainnet.maticvigil.com' } } } };
                const web3Modal = new Web3Modal.default({ providerOptions });
                async function subscribe() {
                  try {
                    const provider = await web3Modal.connect();
                    const ethersProvider = new ethers.providers.Web3Provider(provider);
                    const signer = ethersProvider.getSigner();
                    const contract = new ethers.Contract('${contract}', [
                      'function subscribe(uint256 amount, string currency) payable'
                    ], signer);
                    const currency = prompt('Select currency (USDT/ETH/BTC):')?.toUpperCase() || 'USDT';
                    const amount = currency === 'BTC' ? '0' : ethers.utils.parseUnits(prompt('Enter amount ($5-$50):') || '5', 6);
                    const value = currency === 'ETH' ? ethers.utils.parseEther('0.001') : '0';
                    const tx = await contract.subscribe(amount, currency, { value });
                    await tx.wait();
                    alert('Subscription successful! Funds sent to ${tempWallet}');
                  } catch (e) { alert('Error: ' + e.message); }
                }
              </script>
            </body></html>`
          fs.writeFileSync('premium.html', premiumHtml)
          const mkItem = it => `<item><title><![CDATA[${it.title || 'Opportunity'}]]></title><link>${pick((it.title || '') + ' ' + (it.description || '') + ' ' + (it.src || ''), it.link || '#')}</link><pubDate>${it.date || ''}</pubDate><guid>${it.link || '#'}</guid></item>`
          const rss = `<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"><channel>
            <title>${title}</title><link>${base}</link><description>${desc}</description>
            ${(items || []).slice(0, 60).map(mkItem).join('')}
          </channel></rss>`
          fs.writeFileSync('feed.xml', rss)
          const url = p => (base ? `${base}/${p}` : p)
          const sm = `<?xml version="1.0" encoding="UTF-8"?><urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
            <url><loc>${url('index.html')}</loc></url>
            <url><loc>${url('premium.html')}</loc></url>
            <url><loc>${url('blog/opportunities-2025.md')}</loc></url>
          </urlset>`
          fs.writeFileSync('sitemap.xml', sm)
          // Generate sub-domains for opportunities
          const subDomains = items.slice(0, 10).map((it, i) => ({
            name: `opp${i}.lightunfold.op`,
            link: pick((it.title || '') + ' ' + (it.description || '') + ' ' + (it.src || ''), it.link || '#')
          }))
          fs.writeFileSync('sub-domains.json', JSON.stringify(subDomains, null, 2))
          NODE

      # ================== AGENT: AUTO-AIRDROP ==================
      - name: Agent: Auto-Airdrop
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          import fetch from 'node-fetch'
          const items = JSON.parse(fs.readFileSync('data/opps.scored.json', 'utf8'))
          const airdrops = items.filter(it => (it.title + it.description).toLowerCase().includes('airdrop')).slice(0, 5)
          for (const airdrop of airdrops) {
            try {
              await fetch(airdrop.link, { method: 'GET' }) // Simulate airdrop participation
              console.log('Joined airdrop:', airdrop.title)
            } catch (e) { console.log('Airdrop error:', airdrop.title, e.message) }
          }
          fs.writeFileSync('logs/airdrops.json', JSON.stringify(airdrops, null, 2))
          NODE

      # ================== AGENT: REINVEST ==================
      - name: Agent: Reinvest
        env:
          TEMP_WALLET_PRIVATE_KEY: ${{ secrets.TEMP_WALLET_PRIVATE_KEY }}
          TEMP_WALLET_ADDRESS: ${{ secrets.TEMP_WALLET_ADDRESS }}
        run: |
          node --input-type=module - <<'NODE'
          import Web3 from 'web3'
          import fs from 'fs'
          const web3 = new Web3('https://rpc-mainnet.maticvigil.com')
          const account = web3.eth.accounts.privateKeyToAccount(process.env.TEMP_WALLET_PRIVATE_KEY)
          web3.eth.accounts.wallet.add(account)
          async function reinvest() {
            try {
              const balance = await web3.eth.getBalance(account.address)
              const eth = web3.utils.fromWei(balance, 'ether')
              if (Number(eth) > 0.01) {
                const amount = web3.utils.toWei((Number(eth) * 0.5).toString(), 'ether') // 50% to staking
                await web3.eth.sendTransaction({ from: account.address, to: '0xAavePolygonContract', value: amount }) // Replace with Aave contract
                console.log('Reinvested 50% to staking:', eth * 0.5)
              }
            } catch (e) { console.log('Reinvest error:', e.message) }
          }
          reinvest()
          NODE

      # ================== COMPLIANCE ==================
      - name: Compliance gate
        env:
          BLOCK_DOMAINS: ${{ vars.BLOCK_DOMAINS || 'scam.com,ponzi.net' }}
          BLOCK_WORDS: ${{ vars.BLOCK_WORDS || 'scam,ponzi,illegal,fraud,phishing' }}
          KILL_SWITCH: ${{ secrets.KILL_SWITCH }}
        run: |
          set -e
          if [ "${KILL_SWITCH}" = "OFF" ]; then echo "Kill-switch ON -> cancel"; exit 1; fi
          HTML="index.html"
          if [ -f "$HTML" ]; then
            if [ -n "${BLOCK_DOMAINS}" ]; then
              IFS=, read -ra ds <<< "${BLOCK_DOMAINS}"
              for d in "${ds[@]}"; do grep -qi "$d" "$HTML" && { echo "Blocked domain: $d"; exit 1; }; done
            fi
            if [ -n "${BLOCK_WORDS}" ]; then
              IFS=, read -ra ws <<< "${BLOCK_WORDS}"
              for w in "${ws[@]}"; do grep -qi "$w" "$HTML" && { echo "Blocked word: $w"; exit 1; }; done
            fi
          fi
          echo "Compliance OK"

      # ================== TRADER ==================
      - name: Agent: Trader
        env:
          TRADE_MODE: ${{ inputs.trade_mode || 'paper' }}
          CONF_THRESHOLD: ${{ inputs.confidence_threshold || '0.85' }}
          MAX_TRADE_USD: ${{ vars.MAX_TRADE_USD || 100 }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from 'fs'
          const items = JSON.parse(fs.readFileSync('data/opps.scored.json', 'utf8'))
          const top = items[0] || null
          const fetch = (await import('node-fetch')).default
          const mode = (process.env.TRADE_MODE || 'paper').toLowerCase()
          const thr = Number(process.env.CONF_THRESHOLD || 0.85)
          const maxUSD = Number(process.env.MAX_TRADE_USD || 100) || 100
          if (!top) { console.log('No opportunity'); process.exit(0) }
          if ((top.score || 0) < thr) { console.log('Below threshold -> skip'); process.exit(0) }
          const order = { action: mode === 'live' ? 'live' : 'paper', amountUSD: maxUSD, symbol: top.title.match(/bitcoin|eth|solana|bnb|algo/i)?.[0]?.toUpperCase() || 'INFO', source: top }
          if (mode === 'live' && process.env.TRADE_WEBHOOK_URL) {
            const res = await fetch(process.env.TRADE_WEBHOOK_URL, {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify(order)
            })
            console.log('Webhook status:', res.status)
          } else {
            console.log('Paper trade:', order)
          }
          fs.mkdirSync('logs', { recursive: true })
          fs.writeFileSync('logs/order.json', JSON.stringify(order, null, 2))
          NODE

      # ================== DEPLOY IPFS ==================
      - name: Deploy to IPFS
        env:
          PINATA_API_KEY: ${{ secrets.PINATA_API_KEY }}
          PINATA_API_SECRET: ${{ secrets.PINATA_API_SECRET }}
          FLEEK_API_KEY: ${{ secrets.FLEEK_API_KEY }}
          WEB3_STORAGE_API_KEY: ${{ secrets.WEB3_STORAGE_API_KEY }}
        run: |
          set -e
          if [ -n "${PINATA_API_KEY}" ] && [ -n "${PINATA_API_SECRET}" ]; then
            node --input-type=module - <<'NODE'
            import fs from 'fs'
            import PinataClient from '@pinata/sdk'
            const pinata = new PinataClient(process.env.PINATA_API_KEY, process.env.PINATA_API_SECRET)
            async function pinDirectory() {
              try {
                const options = { pinataMetadata: { name: 'Light Unfold Web3 Site' }, pinataOptions: { cidVersion: 0 } }
                const result = await pinata.pinFromFS('./', options)
                const ipfs = 'https://gateway.pinata.cloud/ipfs/' + result.IpfsHash
                console.log('CID:', result.IpfsHash)
                console.log('IPFS:', ipfs)
                fs.writeFileSync('ipfs-cid.txt', result.IpfsHash + '\n')
                fs.writeFileSync('ipfs-gateway.txt', ipfs + '\n')
              } catch (e) {
                console.error('Pinata error:', e.message)
                process.exit(1)
              }
            }
            pinDirectory()
            NODE
          elif [ -n "${FLEEK_API_KEY}" ]; then
            node --input-type=module - <<'NODE'
            import fs from 'fs'
            import Fleek from '@fleekhq/fleek-sdk'
            const fleek = new Fleek({ apiKey: process.env.FLEEK_API_KEY })
            async function pinDirectory() {
              try {
                const result = await fleek.storage.uploadDirectory({ path: './', name: 'Light Unfold Web3 Site' })
                const ipfs = 'https://ipfs.fleek.co/ipfs/' + result.hash
                console.log('CID:', result.hash)
                console.log('IPFS:', ipfs)
                fs.writeFileSync('ipfs-cid.txt', result.hash + '\n')
                fs.writeFileSync('ipfs-gateway.txt', ipfs + '\n')
              } catch (e) {
                console.error('Fleek error:', e.message)
                process.exit(1)
              }
            }
            pinDirectory()
            NODE
          elif [ -n "${WEB3_STORAGE_API_KEY}" ]; then
            node --input-type=module - <<'NODE'
            import fs from 'fs'
            import { Web3Storage } from '@web3-storage/client'
            const client = new Web3Storage({ token: process.env.WEB3_STORAGE_API_KEY })
            async function pinDirectory() {
              try {
                const files = []
                for (const p of ['index.html', 'premium.html', 'feed.xml', 'sitemap.xml', 'blog/opportunities-2025.md']) {
                  if (fs.existsSync(p)) files.push(new File([fs.readFileSync(p)], p))
                }
                const cid = await client.put(files)
                const ipfs = 'https://dweb.link/ipfs/' + cid
                console.log('CID:', cid)
                console.log('IPFS:', ipfs)
                fs.writeFileSync('ipfs-cid.txt', cid + '\n')
                fs.writeFileSync('ipfs-gateway.txt', ipfs + '\n')
              } catch (e) {
                console.error('Web3.Storage error:', e.message)
                process.exit(1)
              }
            }
            pinDirectory()
            NODE
          else
            echo "No IPFS credentials -> exit" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      # ================== UPDATE OPNS ==================
      - name: Update OPNS Record
        env:
          TEMP_WALLET_PRIVATE_KEY: ${{ secrets.TEMP_WALLET_PRIVATE_KEY }}
        run: |
          CID=$(cat ipfs-cid.txt 2>/dev/null || echo "")
          if [ -z "$CID" ]; then echo "No CID -> skip OPNS update"; exit 0; fi
          node --input-type=module - <<'NODE'
          import Web3 from 'web3'
          import fs from 'fs'
          const web3 = new Web3('https://rpc-mainnet.maticvigil.com')
          const account = web3.eth.accounts.privateKeyToAccount(process.env.TEMP_WALLET_PRIVATE_KEY)
          web3.eth.accounts.wallet.add(account)
          const opnsABI = [{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"cid","type":"string"}],"name":"register","outputs":[],"stateMutability":"nonpayable","type":"function"}]
          const opnsContract = new web3.eth.Contract(opnsABI, '0xOPNSContractAddress') // Replace with actual OPNS contract
          async function updateOPNS() {
            try {
              const cid = fs.readFileSync('ipfs-cid.txt', 'utf8').trim()
              const subDomains = JSON.parse(fs.readFileSync('sub-domains.json', 'utf8') || '[]')
              for (const { name } of subDomains) {
                await opnsContract.methods.register(name, cid).send({ from: account.address, gas: 100000 })
                console.log('OPNS updated:', name, '->', cid)
              }
              await opnsContract.methods.register('lightunfold.op', cid).send({ from: account.address, gas: 100000 })
              console.log('OPNS updated: lightunfold.op ->', cid)
            } catch (e) { console.error('OPNS update error:', e.message) }
          }
          updateOPNS()
          NODE

      # ================== AUTO-SHARE ==================
      - name: Auto-share on Social
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          TWITTER_API_KEY: ${{ secrets.TWITTER_API_KEY }}
          TWITTER_API_SECRET: ${{ secrets.TWITTER_API_SECRET }}
          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}
          TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}
          LENS_API_KEY: ${{ secrets.LENS_API_KEY }}
          FARCASTER_API_KEY: ${{ secrets.FARCASTER_API_KEY }}
          SITE_BASE: ${{ vars.SITE_BASE || 'https://lightunfold.op' }}
        run: |
          TOP=$(jq -r '.[0].title // empty' data/opps.scored.json 2>/dev/null || echo "")
          IPFS=$(cat ipfs-gateway.txt 2>/dev/null || echo "")
          SUBDOMAINS=$(cat sub-domains.json 2>/dev/null | jq -r '.[] | .name + ": " + .link' || echo "")
          MSG=${TOP:+🚀 New on lightunfold.op: ${TOP}! Join airdrops, NFTs, DeFi at ${SITE_BASE} or ${IPFS} #Web3 #Crypto\n\nSub-domains:\n${SUBDOMAINS}}
          [ -n "$DISCORD_WEBHOOK_URL" ] && curl -s -X POST -H 'Content-Type: application/json' -d "{\"content\":\"${MSG}\"}" "$DISCORD_WEBHOOK_URL" || true
          if [ -n "${TELEGRAM_BOT_TOKEN}" ] && [ -n "${TELEGRAM_CHAT_ID}" ]; then
            curl -s "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              --data-urlencode "chat_id=${TELEGRAM_CHAT_ID}" \
              --data-urlencode "text=${MSG}" >/dev/null || true
          fi
          if [ -n "${TWITTER_API_KEY}" ]; then
            node --input-type=module - <<'NODE'
            import fetch from 'node-fetch'
            async function tweet() {
              try {
                const res = await fetch('https://api.twitter.com/2/tweets', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${{ secrets.TWITTER_ACCESS_TOKEN }}`
                  },
                  body: JSON.stringify({ text: process.env.MSG })
                })
                console.log('Tweet posted:', await res.json())
              } catch (e) { console.error('Tweet error:', e.message) }
            }
            tweet()
            NODE
          fi
          if [ -n "${LENS_API_KEY}" ]; then
            node --input-type=module - <<'NODE'
            import fetch from 'node-fetch'
            async function postLens() {
              try {
                const res = await fetch('https://api.lens.xyz/posts', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${{ secrets.LENS_API_KEY }}`
                  },
                  body: JSON.stringify({ content: process.env.MSG })
                })
                console.log('Lens posted:', await res.json())
              } catch (e) { console.error('Lens error:', e.message) }
            }
            postLens()
            NODE
          fi
          if [ -n "${FARCASTER_API_KEY}" ]; then
            node --input-type=module - <<'NODE'
            import fetch from 'node-fetch'
            async function postFarcaster() {
              try {
                const res = await fetch('https://api.farcaster.network/casts', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${{ secrets.FARCASTER_API_KEY }}`
                  },
                  body: JSON.stringify({ text: process.env.MSG })
                })
                console.log('Farcaster posted:', await res.json())
              } catch (e) { console.error('Farcaster error:', e.message) }
            }
            postFarcaster()
            NODE
          fi
