<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Siêu Metaverse Web3</title>
  <style>
    :root {
      --bg: #1a1a1a; --card: #2c2c2c; --text: #fff; --accent: #27AE60; --gold: #FFD700; --blue: #1E90FF;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text); }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    header { text-align: center; padding: 20px; }
    h1 { font-size: 2.5em; color: var(--blue); }
    #globe3d { width: 100%; height: 300px; margin: 20px 0; }
    .section { margin: 20px 0; }
    .card { background: var(--card); border-radius: 12px; padding: 16px; margin: 8px 0; }
    .card b { color: var(--gold); }
    .muted { color: #aaa; font-size: 0.9em; }
    .btn { background: var(--accent); color: #fff; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; margin: 4px; transition: transform 0.2s; }
    .btn:hover { transform: scale(1.05); }
    .btn.out { background: transparent; border: 1px solid var(--accent); }
    .btn.connecting::after { content: '⏳'; margin-left: 8px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    #ticker { font-size: 1.1em; color: var(--gold); text-align: center; }
    #chat { position: fixed; bottom: 20px; right: 20px; width: 300px; background: var(--card); border-radius: 12px; padding: 16px; }
    .bubble { margin: 8px 0; padding: 8px; border-radius: 8px; }
    .bubble.me { background: var(--accent); margin-left: 20%; }
    .bubble.ai { background: var(--blue); margin-right: 20%; }
    #premium { display: none; }
    #premium.unlocked { display: block; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Siêu Metaverse Web3</h1>
      <canvas id="globe3d"></canvas>
      <button id="connectWallet" class="btn">Kết nối ví</button>
    </header>
    <div id="ticker">Đang tải dữ liệu thị trường...</div>
    <div class="section">
      <h2>Top 3 Tokens</h2>
      <div id="tokenPro"></div>
      <div id="tokenFree"></div>
    </div>
    <div class="section" id="premium">
      <h2>Premium Content</h2>
    </div>
    <div class="section">
      <h2>Giới thiệu</h2>
      <div class="row">
        <a id="cta_binance" class="btn" href="#">Binance</a>
        <a id="cta_algos" class="btn out" href="#">AlgosOne</a>
      </div>
    </div>
    <div id="chat">
      <div id="chatBody"></div>
      <input id="chatInput" placeholder="Hỏi AI..." style="width: 100%; padding: 8px; border-radius: 8px; border: none;">
    </div>
  </div>
  <script type="application/json" id="SITE_CONFIG">
    {
      "ai_api_url": "https://api.x.ai/v1",
      "ai_api_key": "YOUR_GROK3_API_KEY_HERE",
      "coingecko_api": "https://api.coingecko.com/api/v3",
      "chainlink_api": "https://chainlink-api.com", // Giả định
      "push_protocol": "https://app.push.org", // Giả định
      "lens_protocol": "https://api.lens.dev", // Giả định
      "gelato_api": "https://api.gelato.network", // Giả định
      "nft_contract": "0xYOUR_NFT_CONTRACT_ADDRESS",
      "payments": {
        "eth": {
          "id": "0x54E15A7b6d4213beE87800432A151d794638E3C2",
          "min": 0.01,
          "token": "ETH"
        }
      },
      "links": {
        "binance": "https://accounts.binance.com/register?ref=GRO_20338_9V44N",
        "algos": "https://algosone.page.link/MbtR"
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script>
    const st = { 
      lang: (localStorage.getItem('lang') || (navigator.language || 'vi')).toLowerCase().startsWith('vi') ? 'vi' : 'en',
      theme: localStorage.getItem('theme') || 'dark',
      points: Number(localStorage.getItem('points') || 0),
      rev: Number(localStorage.getItem('rev') || 0),
      cfg: {}
    };
    try { st.cfg = JSON.parse(document.getElementById('SITE_CONFIG').textContent.trim()); } catch (e) { st.cfg = {}; }
    let provider, signer, walletAddress;

    // DOM helpers
    const $ = id => document.getElementById(id);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const setHref = (sel, href) => href && (document.querySelector(sel).href = href);

    // Initialize links
    setHref('#cta_binance', st.cfg.links?.binance);
    setHref('#cta_algos', st.cfg.links?.algos);

    // Wallet connection
    async function connectWallet() {
      $('#connectWallet').classList.add('connecting');
      try {
        if (window.ethereum) {
          provider = new ethers.providers.Web3Provider(window.ethereum);
          await provider.send("eth_requestAccounts", []);
          signer = provider.getSigner();
          walletAddress = await signer.getAddress();
          $('#connectWallet').textContent = `Connected: ${walletAddress.slice(0,6)}...${walletAddress.slice(-4)}`;
          $('#connectWallet').classList.add('connected');
          checkOnChainUnlock();
        } else {
          alert('Install MetaMask!');
        }
      } finally {
        $('#connectWallet').classList.remove('connecting');
      }
    }
    $('#connectWallet').onclick = connectWallet;

    // On-chain payment check
    async function checkOnChainUnlock() {
      if (!signer) return;
      const balance = await provider.getBalance(walletAddress);
      if (balance.gte(ethers.utils.parseEther(st.cfg.payments.eth.min.toString()))) {
        localStorage.setItem('premium_unlocked', '1');
        paintPremium();
      }
    }

    async function doUnlock() {
      if (!signer) return alert('Connect wallet first!');
      const tx = await signer.sendTransaction({
        to: st.cfg.payments.eth.id,
        value: ethers.utils.parseEther(st.cfg.payments.eth.min.toString())
      });
      await tx.wait();
      localStorage.setItem('premium_unlocked', '1');
      paintPremium();
      addBubble('Premium unlocked!', 'me');
    }

    function remember() {
      if (localStorage.getItem('premium_unlocked') === '1') {
        paintPremium();
      }
    }

    function relock() {
      localStorage.removeItem('premium_unlocked');
      $('#premium').classList.remove('unlocked');
      $('#premium').style.display = 'none';
    }

    // AI initialization
    async function initAI() {
      if (st.cfg.ai_api_key === 'YOUR_GROK3_API_KEY_HERE') {
        console.warn('Missing AI key. Advanced features disabled.');
        return false;
      }
      try {
        const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
          body: JSON.stringify({ model: 'grok-3', messages: [{ role: 'user', content: 'Ping' }], max_tokens: 10 })
        });
        if (res.ok) {
          console.log('AI initialized successfully!');
          return true;
        }
      } catch (e) { console.warn('AI init failed', e); }
      return false;
    }

    // Auto beautify UI
    async function autoBeautify() {
      if (!(await initAI())) return;
      try {
        const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
          body: JSON.stringify({
            model: 'grok-3',
            messages: [{ role: 'user', content: 'Suggest CSS to beautify a crypto Metaverse web app with dark theme, green accents, and psychological triggers (FOMO, urgency). Output only CSS.' }],
            max_tokens: 1000
          })
        });
        const data = await res.json();
        const css = data.choices[0].message.content.match(/```css\n([\s\S]*?)\n```/)?.[1];
        if (css) {
          const styleEl = document.createElement('style');
          styleEl.textContent = css;
          document.head.appendChild(styleEl);
        }
      } catch (e) { console.warn('Auto beautify failed', e); }
    }

    // Auto viral (Lens Protocol & Push Protocol)
    async function autoViral() {
      if (!(await initAI()) || Math.random() > 0.2) return;
      try {
        const res = await fetch(st.cfg.coingecko_api + '/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=1');
        const topToken = (await res.json())[0];
        const aiRes = await fetch(st.cfg.ai_api_url + '/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
          body: JSON.stringify({
            model: 'grok-3',
            messages: [{ role: 'user', content: `Tạo bài đăng viral (Twitter, Lens, Telegram) về token ${topToken.symbol.toUpperCase()} với giá $${topToken.current_price}, 24h: ${topToken.price_change_percentage_24h}%. Thêm FOMO và link: ${st.cfg.links.binance}` }],
            max_tokens: 1000
          })
        });
        const data = await aiRes.json();
        const post = data.choices[0].message.content;
        // Twitter
        window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(post)}`, '_blank');
        // Lens Protocol (giả định)
        await fetch(st.cfg.lens_protocol + '/posts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: post, profileId: 'YOUR_LENS_PROFILE_ID' })
        });
        // Push Protocol (giả định)
        await fetch(st.cfg.push_protocol + '/notifications', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: post, recipients: [walletAddress] })
        });
      } catch (e) { console.warn('Auto viral failed', e); }
    }

    // Fetch token data
    async function fetchRealtimeTokens() {
      try {
        const res = await fetch(st.cfg.coingecko_api + '/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=10');
        const tokens = await res.json();
        const top3 = tokens.slice(0, 3);
        const rest = tokens.slice(3, 6);
        $('#tokenPro').innerHTML = top3.map(t => cardToken(t).outerHTML).join('');
        $('#tokenFree').innerHTML = rest.map(t => cardToken(t).outerHTML).join('');
        $('#ticker').textContent = `Hot: ${top3[0].symbol.toUpperCase()} $${top3[0].current_price} (${top3[0].price_change_percentage_24h.toFixed(2)}%)`;
      } catch (e) { console.warn('Fetch tokens failed, trying Chainlink...', e); }
    }

    function cardToken(t) {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `<b>${t.name}</b><div class="muted">$${t.current_price} (${t.price_change_percentage_24h.toFixed(2)}%)</div>
        <div class="row"><button class="btn" data-sym="${t.symbol.toUpperCase()}">Phân tích</button><button class="btn out" data-stake>Stake</button></div>`;
      return card;
    }

    // Premium content
    function paintPremium() {
      $('#premium').classList.add('unlocked');
      $('#premium').style.display = 'block';
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `<b>Chào mừng Premium!</b><div class="muted">Phân tích độc quyền, NFT & Yield Farming</div><button class="btn" onclick="relock()">Thoát Premium</button>`;
      $('#premium').appendChild(card);
      loadNFTs();
      dynamicNFT();
    }

    // Chat
    function addBubble(text, who) {
      const div = document.createElement('div');
      div.className = `bubble ${who}`;
      div.textContent = text;
      $('#chatBody').appendChild(div);
      $('#chatBody').scrollTop = $('#chatBody').scrollHeight;
    }

    $('#chatInput').onkeypress = async e => {
      if (e.key === 'Enter' && $('#chatInput').value.trim()) {
        const query = $('#chatInput').value;
        addBubble(query, 'me');
        $('#chatInput').value = '';
        if (!(await initAI())) return addBubble('AI không khả dụng', 'ai');
        try {
          const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
            body: JSON.stringify({
              model: 'grok-3',
              messages: [{ role: 'user', content: query }],
              max_tokens: 1000,
              temperature: 0.2
            })
          });
          const data = await res.json();
          addBubble(data.choices[0].message.content, 'ai');
        } catch (e) { addBubble('Lỗi AI, thử lại sau.', 'ai'); }
      }
    };

    // Token analysis
    async function aiAnalyzeToken(symbol) {
      if (!(await initAI())) return;
      try {
        const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
          body: JSON.stringify({
            model: 'grok-3',
            messages: [{ role: 'user', content: `Phân tích token ${symbol} dựa trên dữ liệu CoinGecko và Chainlink (giá, volume, 24h change, on-chain metrics). Gợi ý chiến lược giao dịch (khung 1D/4H, mức hỗ trợ/kháng cự, tâm lý thị trường).` }],
            max_tokens: 1000
          })
        });
        const data = await res.json();
        const analysis = data.choices[0].message.content;
        addBubble(analysis, 'ai');
        if (localStorage.getItem('premium_unlocked') === '1') {
          const card = document.createElement('div');
          card.className = 'card';
          card.innerHTML = `<b>Phân tích ${symbol}</b><div class="muted">${analysis}</div>`;
          $('#premium').appendChild(card);
        }
      } catch (e) { console.warn('AI analysis failed', e); }
    }

    // Job matching
    async function aiJobMatching() {
      if (!(await initAI())) return;
      const userEvents = JSON.parse(localStorage.getItem('userEvents') || '[]');
      const marketData = await (await fetch(`${st.cfg.coingecko_api}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=5`)).json();
      const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
        body: JSON.stringify({
          model: 'grok-3',
          messages: [{ role: 'user', content: `Dựa trên hành vi người dùng: ${JSON.stringify(userEvents.slice(-10))} và thị trường: ${JSON.stringify(marketData.slice(0,2))}. Gợi ý cơ hội tài chính (trading, staking, yield farming) phù hợp.` }],
          max_tokens: 1000
        })
      });
      const data = await res.json();
      const opportunities = data.choices[0].message.content;
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `<b>Cơ hội cá nhân hóa</b><div class="muted">${opportunities}</div>`;
      $('#premium').appendChild(card);
    }

    // Self-upgrading
    async function selfUpgrade() {
      if (!(await initAI())) return;
      const currentCode = document.documentElement.outerHTML;
      const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
        body: JSON.stringify({
          model: 'grok-3',
          messages: [{ role: 'user', content: `Analyze web app code: ${currentCode.slice(0, 2000)}. Suggest new features (JS/CSS) to enhance Metaverse Web3 functionality (e.g., cross-chain, gamification). Output code to eval.` }],
          max_tokens: 2000
        })
      });
      const data = await res.json();
      const newCode = data.choices[0].message.content.match(/```(?:js|css)\n([\s\S]*?)\n```/)?.[1];
      if (newCode) {
        if (newCode.includes('css')) {
          const styleEl = document.createElement('style');
          styleEl.textContent = newCode;
          document.head.appendChild(styleEl);
        } else {
          eval(newCode);
        }
      }
    }

    // Self-healing
    async function selfHeal() {
      if (!(await initAI())) return;
      const checks = [
        { id: 'tokenPro', test: () => $('#tokenPro').children.length > 0, msg: 'Token cards missing' },
        { id: 'coingecko', test: async () => (await fetch(st.cfg.coingecko_api + '/ping')).ok, msg: 'CoinGecko API down' }
      ];
      for (const check of checks) {
        if (!(await check.test())) {
          const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
            body: JSON.stringify({
              model: 'grok-3',
              messages: [{ role: 'user', content: `Fix error in crypto web app: ${check.msg}. Provide JS/CSS to eval.` }],
              max_tokens: 1000
            })
          });
          const data = await res.json();
          const fixCode = data.choices[0].message.content;
          if (fixCode.includes('css')) {
            const styleEl = document.createElement('style');
            styleEl.textContent = fixCode.match(/```css\n([\s\S]*?)\n```/)?.[1];
            document.head.appendChild(styleEl);
          } else {
            eval(fixCode);
          }
          if (check.id === 'coingecko') {
            st.cfg.coingecko_api = 'https://api.binance.com/api/v3';
            fetchRealtimeTokens();
          }
        }
      }
    }

    // User behavior tracking
    async function trackUserBehavior() {
      const events = JSON.parse(localStorage.getItem('userEvents') || '[]');
      $$('.card, .btn').forEach(el => {
        el.addEventListener('click', () => {
          events.push({ type: 'click', target: el.id || el.textContent, time: Date.now() });
          localStorage.setItem('userEvents', JSON.stringify(events.slice(-100)));
        });
      });
      setInterval(async () => {
        if (!(await initAI())) return;
        const userEvents = JSON.parse(localStorage.getItem('userEvents') || '[]');
        if (userEvents.length) {
          const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
            body: JSON.stringify({
              model: 'grok-3',
              messages: [{ role: 'user', content: `Analyze user behavior: ${JSON.stringify(userEvents.slice(-10))}. Suggest UI improvements or content prioritization.` }],
              max_tokens: 1000
            })
          });
          const data = await res.json();
          const suggestion = data.choices[0].message.content;
          if (suggestion.includes('CSS')) {
            const styleEl = document.createElement('style');
            styleEl.textContent = suggestion.match(/```css\n([\s\S]*?)\n```/)?.[1];
            document.head.appendChild(styleEl);
          } else if (suggestion.includes('content')) {
            $('#ticker').textContent = suggestion;
          }
        }
      }, 300000);
    }

    // AI self-learning
    async function aiSelfLearn() {
      if (!(await initAI())) return;
      const history = JSON.parse(localStorage.getItem('aiHistory') || '[]');
      setInterval(async () => {
        const userEvents = JSON.parse(localStorage.getItem('userEvents') || '[]');
        const marketData = await (await fetch(`${st.cfg.coingecko_api}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=5`)).json();
        const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
          body: JSON.stringify({
            model: 'grok-3',
            messages: [{ role: 'user', content: `Learn from user events: ${JSON.stringify(userEvents.slice(-10))} and market data: ${JSON.stringify(marketData.slice(0,2))}. Optimize token suggestions, pricing, and FOMO content.` }],
            max_tokens: 1000
          })
        });
        const data = await res.json();
        const suggestions = data.choices[0].message.content;
        history.push({ time: Date.now(), suggestions });
        localStorage.setItem('aiHistory', JSON.stringify(history.slice(-50)));
        const newTokens = JSON.parse(suggestions).tokens || [];
        $('#tokenPro').innerHTML = newTokens.map(t => cardToken(t).outerHTML).join('');
      }, 3600000);
    }

    // Affiliate optimization
    async function optimizeAffiliate() {
      if (!(await initAI())) return;
      const clicks = JSON.parse(localStorage.getItem('userEvents') || '[]').reduce((acc, e) => {
        if (e.target.includes('binance')) acc.binance = (acc.binance || 0) + 1;
        if (e.target.includes('algos')) acc.algos = (acc.algos || 0) + 1;
        return acc;
      }, {});
      const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
        body: JSON.stringify({
          model: 'grok-3',
          messages: [{ role: 'user', content: `Optimize affiliate links based on clicks: ${JSON.stringify(clicks)}. Suggest primary link.` }],
          max_tokens: 1000
        })
      });
      const data = await res.json();
      const primaryLink = data.choices[0].message.content.includes('binance') ? st.cfg.links.binance : st.cfg.links.algos;
      setHref('#cta_binance', primaryLink);
      setHref('#cta_algos', primaryLink);
    }

    // Staking ETH
    async function stakeEth() {
      if (!signer) return alert('Connect wallet first!');
      const lidoContract = new ethers.Contract(
        '0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84',
        ['function submit(address _referral) payable returns (uint256)'],
        signer
      );
      const tx = await lidoContract.submit(st.cfg.payments.eth.id, { value: ethers.utils.parseEther('0.01') });
      await tx.wait();
      st.rev += 0.01 * 1000;
      localStorage.setItem('rev', st.rev);
      addBubble('Staked 0.01 ETH with Lido!', 'me');
    }

    // Dynamic NFT
    async function dynamicNFT() {
      if (!(await initAI())) return;
      const marketData = await (await fetch(`${st.cfg.coingecko_api}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=1`)).json();
      const topToken = marketData[0];
      const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
        body: JSON.stringify({
          model: 'grok-3',
          messages: [{ role: 'user', content: `Generate NFT metadata for token ${topToken.symbol} (price: $${topToken.current_price}). Include name, image URL, description with FOMO elements.` }],
          max_tokens: 1000
        })
      });
      const data = await res.json();
      const meta = JSON.parse(data.choices[0].message.content);
      const nftCard = document.createElement('div');
      nftCard.className = 'card';
      nftCard.innerHTML = `<b>${meta.name}</b><img src="${meta.image}" style="width:100%;border-radius:12px">
      <div class="muted">${meta.description}</div><button class="btn">Mint NFT</button>`;
      nftCard.querySelector('button').onclick = async () => {
        if (st.cfg.nft_contract === '0xYOUR_NFT_CONTRACT_ADDRESS') return;
        const nftContract = new ethers.Contract(st.cfg.nft_contract, ['function mint(string memory uri)'], signer);
        const tx = await nftContract.mint(JSON.stringify(meta));
        await tx.wait();
        addBubble(`Minted NFT for ${topToken.symbol}!`, 'me');
      };
      $('#premium').appendChild(nftCard);
    }

    // Psychological triggers
    async function psychologicalTriggers() {
      if (!(await initAI())) return;
      const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
        body: JSON.stringify({
          model: 'grok-3',
          messages: [{ role: 'user', content: `Analyze X sentiment for crypto market. Generate UI elements (colors, animations) to trigger FOMO and urgency.` }],
          max_tokens: 1000
        })
      });
      const data = await res.json();
      const css = data.choices[0].message.content.match(/```css\n([\s\S]*?)\n```/)?.[1];
      if (css) {
        const styleEl = document.createElement('style');
        styleEl.textContent = css;
        document.head.appendChild(styleEl);
      }
    }

    // Omni-presence (Metaverse integration)
    async function metaversePresence() {
      if (!(await initAI())) return;
      const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
        body: JSON.stringify({
          model: 'grok-3',
          messages: [{ role: 'user', content: `Generate banner for Decentraland/Sandbox to promote this Web3 app with link: ${st.cfg.links.binance}.` }],
          max_tokens: 1000
        })
      });
      const data = await res.json();
      const banner = data.choices[0].message.content;
      // Giả định gửi banner đến Metaverse (Decentraland API)
      await fetch('https://api.decentraland.org/v1/banners', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: banner, link: st.cfg.links.binance })
      });
    }

    // 3D Globe
    try {
      const canvas = document.getElementById('globe3d');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      const DPR = Math.min(window.devicePixelRatio || 1, 2);
      const W = canvas.clientWidth || 300, H = canvas.clientHeight || 300;
      renderer.setPixelRatio(DPR); renderer.setSize(W, H, false);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, W/H, 0.1, 100); camera.position.z = 6;

      const ambient = new THREE.AmbientLight(0x1E90FF, 0.6);
      const sun = new THREE.DirectionalLight(0xFFD700, 0.8);
      sun.position.set(6, 3, 4);
      scene.add(ambient, sun);

      const loader = new THREE.TextureLoader();
      const earthTex = loader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
      const normalTx = loader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg');
      const specTx = loader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg');
      const cloudTx = loader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png');
      const moonTex = loader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg');

      const earth = new THREE.Mesh(
        new THREE.SphereGeometry(2.4, 64, 64),
        new THREE.MeshPhongMaterial({
          map: earthTex,
          bumpMap: normalTx,
          bumpScale: 0.04,
          specularMap: specTx,
          specular: new THREE.Color(0x27AE60),
          shininess: 20
        })
      );
      scene.add(earth);

      const tint = new THREE.Mesh(
        new THREE.SphereGeometry(2.405, 64, 64),
        new THREE.MeshBasicMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.2 })
      );
      scene.add(tint);

      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(2.46, 64, 64),
        new THREE.MeshLambertMaterial({ map: cloudTx, transparent: true, opacity: 0.45 })
      );
      scene.add(clouds);

      const moon = new THREE.Mesh(
        new THREE.SphereGeometry(0.65, 32, 32),
        new THREE.MeshStandardMaterial({ map: moonTex, roughness: 1, metalness: 0 })
      );
      const moonLight = new THREE.PointLight(0xFFD700, 1.2, 18);
      const moonGroup = new THREE.Group();
      moonGroup.add(moon, moonLight);
      scene.add(moonGroup);

      function resize() {
        const w = canvas.clientWidth || 300, h = canvas.clientHeight || 300;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize);

      let t = 0;
      function animate() {
        requestAnimationFrame(animate);
        earth.rotation.y += 0.002;
        tint.rotation.y += 0.002;
        clouds.rotation.y += 0.0025;
        t += 0.002;
        const r = 5.2;
        moonGroup.position.set(Math.cos(t) * r, Math.sin(t * 1.1) * 0.8, Math.sin(t) * r * 0.4);
        moonLight.position.set(0, 0, 0);
        renderer.render(scene, camera);
      }
      animate();
    } catch (e) { console.warn('WebGL not available, fallback static.', e); }

    // Initialize
    (async () => {
      if (await initAI()) {
        autoBeautify();
        autoViral();
        fetchRealtimeTokens();
        trackUserBehavior();
        selfHeal();
        aiSelfLearn();
        optimizeAffiliate();
        aiJobMatching();
        selfUpgrade();
        psychologicalTriggers();
        metaversePresence();
        if (localStorage.getItem('premium_unlocked') === '1') dynamicNFT();
      }
      setInterval(autoViral, 3600000);
      setInterval(selfHeal, 60000);
      setInterval(selfUpgrade, 86400000);
      setInterval(psychologicalTriggers, 1800000);
      setInterval(metaversePresence, 7200000);
      remember();
    })();
  </script>
</body>
</html>
