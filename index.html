<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Si√™u Metaverse Web3 √Ånh S√°ng</title>
  <style>
    :root { --bg: #1a1a1a; --card: #2c2c2c; --text: #fff; --accent: #27AE60; --gold: #FFD700; --blue: #1E90FF; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text); }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    header { text-align: center; padding: 20px; }
    h1 { font-size: 2.5em; color: var(--blue); animation: glow 2s infinite; }
    @keyframes glow { 0% { text-shadow: 0 0 10px var(--blue); } 50% { text-shadow: 0 0 20px var(--gold); } 100% { text-shadow: 0 0 10px var(--blue); } }
    #globe3d { width: 100%; height: 300px; margin: 20px 0; }
    .section { margin: 20px 0; }
    .card { background: var(--card); border-radius: 12px; padding: 16px; margin: 8px 0; animation: pulse 2s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }
    .card b { color: var(--gold); }
    .muted { color: #aaa; font-size: 0.9em; }
    .btn { background: var(--accent); color: #fff; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; margin: 4px; transition: transform 0.2s; }
    .btn:hover { transform: scale(1.05); }
    .btn.out { background: transparent; border: 1px solid var(--accent); }
    .btn.connecting::after { content: '‚è≥'; margin-left: 8px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    #ticker { font-size: 1.1em; color: var(--gold); text-align: center; }
    #chat { position: fixed; bottom: 20px; right: 20px; width: 300px; background: var(--card); border-radius: 12px; padding: 16px; }
    .bubble { margin: 8px 0; padding: 8px; border-radius: 8px; }
    .bubble.me { background: var(--accent); margin-left: 20%; }
    .bubble.ai { background: var(--blue); margin-right: 20%; }
    #premium { display: none; }
    #premium.unlocked { display: block; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Si√™u Metaverse Web3 √Ånh S√°ng</h1>
      <canvas id="globe3d"></canvas>
      <button id="connectWallet" class="btn">K·∫øt n·ªëi v√≠</button>
    </header>
    <div id="ticker">ƒêang t·∫£i d·ªØ li·ªáu th·ªã tr∆∞·ªùng...</div>
    <div class="section">
      <h2>Top 3 Tokens</h2>
      <div id="tokenPro"></div>
      <div id="tokenFree"></div>
    </div>
    <div class="section" id="premium">
      <h2>Premium Content</h2>
    </div>
    <div class="section">
      <h2>Gi·ªõi thi·ªáu</h2>
      <div class="row">
        <a id="cta_binance" class="btn" href="#">Binance</a>
        <a id="cta_algos" class="btn out" href="#">AlgosOne</a>
      </div>
    </div>
    <div id="chat">
      <div id="chatBody"></div>
      <input id="chatInput" placeholder="Nh·∫≠p t·ª´ kh√≥a..." style="width: 100%; padding: 8px; border-radius: 8px; border: none;">
    </div>
  </div>
  <script type="application/json" id="SITE_CONFIG">
    {
      "ai_api_url": "https://api.x.ai/v1",
      "ai_api_key": "YOUR_GROK3_API_KEY_HERE",
      "infura_url": "https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161",
      "coingecko_api": "https://api.coingecko.com/api/v3",
      "ipfs_gateway": "https://ipfs.io/ipfs",
      "nft_contract": "0xYOUR_NFT_CONTRACT_ADDRESS",
      "payments": {
        "eth": {
          "id": "0x54E15A7b6d4213beE87800432A151d794638E3C2",
          "min": 0.01,
          "token": "ETH"
        }
      },
      "links": {
        "binance": "https://accounts.binance.com/register?ref=GRO_20338_9V44N",
        "algos": "https://algosone.page.link/MbtR"
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script>
    const st = { 
      lang: (localStorage.getItem('lang') || (navigator.language || 'vi')).toLowerCase().startsWith('vi') ? 'vi' : 'en',
      theme: localStorage.getItem('theme') || 'dark',
      points: Number(localStorage.getItem('points') || 0),
      rev: Number(localStorage.getItem('rev') || 0),
      cfg: {}
    };
    try { st.cfg = JSON.parse(document.getElementById('SITE_CONFIG').textContent.trim()); } catch (e) { st.cfg = {}; }
    let provider, signer, walletAddress;

    // DOM helpers
    const $ = id => document.getElementById(id);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const setHref = (sel, href) => href && (document.querySelector(sel).href = href);

    // Initialize links
    setHref('#cta_binance', st.cfg.links?.binance);
    setHref('#cta_algos', st.cfg.links?.algos);

    // Wallet connection
    async function connectWallet() {
      $('#connectWallet').classList.add('connecting');
      try {
        if (window.ethereum) {
          provider = new ethers.providers.Web3Provider(window.ethereum);
          await provider.send("eth_requestAccounts", []);
          signer = provider.getSigner();
          walletAddress = await signer.getAddress();
          $('#connectWallet').textContent = `Connected: ${walletAddress.slice(0,6)}...${walletAddress.slice(-4)}`;
          $('#connectWallet').classList.add('connected');
          checkOnChainUnlock();
          autoRevenue();
        } else {
          alert('Install MetaMask!');
        }
      } finally {
        $('#connectWallet').classList.remove('connecting');
      }
    }
    $('#connectWallet').onclick = connectWallet;

    // On-chain payment check
    async function checkOnChainUnlock() {
      if (!signer) return;
      const balance = await provider.getBalance(walletAddress);
      if (balance.gte(ethers.utils.parseEther(st.cfg.payments.eth.min.toString()))) {
        localStorage.setItem('premium_unlocked', '1');
        paintPremium();
      }
    }

    async function doUnlock() {
      if (!signer) return alert('Connect wallet first!');
      const tx = await signer.sendTransaction({
        to: st.cfg.payments.eth.id,
        value: ethers.utils.parseEther(st.cfg.payments.eth.min.toString())
      });
      await tx.wait();
      localStorage.setItem('premium_unlocked', '1');
      paintPremium();
      addBubble('Premium unlocked!', 'me');
    }

    function remember() {
      if (localStorage.getItem('premium_unlocked') === '1') {
        paintPremium();
      }
    }

    function relock() {
      localStorage.removeItem('premium_unlocked');
      $('#premium').classList.remove('unlocked');
      $('#premium').style.display = 'none';
    }

    // Local AI heuristics
    function localAI(query) {
      const keywords = query.toLowerCase().split(' ');
      const responses = {
        'ph√¢n t√≠ch': 'Mua ·ªü h·ªó tr·ª£, b√°n ·ªü kh√°ng c·ª±. Volume tƒÉng l√† t√≠n hi·ªáu m·∫°nh!',
        'g·ª£i √Ω': 'Token hot: ETH, BTC, BNB. Stake ETH tr√™n Lido cho APY 4-6%.',
        'fomo': `üöÄ ${keywords[1] || 'ETH'} ƒëang moon! ƒêƒÉng k√Ω ngay: ${st.cfg.links.binance}`,
        'moon': `üåô C∆° h·ªôi v√†ng v·ªõi ${keywords[1] || 'BNB'}! Nhanh tay: ${st.cfg.links.binance}`,
        'rocket': `üî• ${keywords[1] || 'BTC'} tƒÉng t·ªëc! Join: ${st.cfg.links.binance}`
      };
      return responses[keywords[0]] || `C∆° h·ªôi v·ªõi ${keywords[0] || 'ETH'}! ƒêƒÉng k√Ω: ${st.cfg.links.binance}`;
    }

    // AI initialization (optional)
    async function initAI() {
      if (st.cfg.ai_api_key === 'YOUR_GROK3_API_KEY_HERE') {
        console.log('No AI key, using local heuristics.');
        return false;
      }
      try {
        const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
          body: JSON.stringify({ model: 'grok-3', messages: [{ role: 'user', content: 'Ping' }], max_tokens: 10 })
        });
        if (res.ok) {
          console.log('AI initialized successfully!');
          return true;
        }
      } catch (e) { console.warn('AI init failed, using local.', e); }
      return false;
    }

    // Auto beautify UI
    async function autoBeautify() {
      if (await initAI()) {
        try {
          const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
            body: JSON.stringify({
              model: 'grok-3',
              messages: [{ role: 'user', content: 'Suggest CSS for a Metaverse Web3 app with cosmic animations, FOMO triggers, and light-speed effects.' }],
              max_tokens: 1000
            })
          });
          const data = await res.json();
          const css = data.choices[0].message.content.match(/```css\n([\s\S]*?)\n```/)?.[1];
          if (css) {
            const styleEl = document.createElement('style');
            styleEl.textContent = css;
            document.head.appendChild(styleEl);
          }
        } catch (e) { console.warn('AI beautify failed, using local.', e); }
      } else {
        const styleEl = document.createElement('style');
        styleEl.textContent = `.card { animation: cosmic 3s infinite; } @keyframes cosmic { 0% { box-shadow: 0 0 10px var(--blue); } 50% { box-shadow: 0 0 20px var(--gold); } 100% { box-shadow: 0 0 10px var(--blue); } }`;
        document.head.appendChild(styleEl);
      }
    }

    // Auto viral
    async function autoViral() {
      const keywords = JSON.parse(localStorage.getItem('userEvents') || '[]').slice(-1)[0]?.target || 'FOMO';
      const post = (await initAI()) ? 
        (await (await fetch(st.cfg.ai_api_url + '/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
          body: JSON.stringify({
            model: 'grok-3',
            messages: [{ role: 'user', content: `T·∫°o b√†i ƒëƒÉng viral v·ªõi t·ª´ kh√≥a "${keywords}" v√† link: ${st.cfg.links.binance}` }],
            max_tokens: 1000
          })
        })).json().then(d => d.choices[0].message.content) :
        localAI(keywords);
      window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(post)}`, '_blank');
      try {
        await fetch(st.cfg.ipfs_gateway + '/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: post, link: st.cfg.links.binance })
        });
      } catch (e) { console.warn('Viral failed', e); }
    }

    // Fetch token data
    async function fetchRealtimeTokens() {
      try {
        provider = provider || new ethers.providers.JsonRpcProvider(st.cfg.infura_url);
        const res = await fetch(st.cfg.coingecko_api + '/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=10');
        const tokens = await res.json();
        const top3 = tokens.slice(0, 3);
        const rest = tokens.slice(3, 6);
        $('#tokenPro').innerHTML = top3.map(t => cardToken(t).outerHTML).join('');
        $('#tokenFree').innerHTML = rest.map(t => cardToken(t).outerHTML).join('');
        $('#ticker').textContent = `Hot: ${top3[0].symbol.toUpperCase()} $${top3[0].current_price} (${top3[0].price_change_percentage_24h.toFixed(2)}%)`;
      } catch (e) {
        console.warn('Fetch tokens failed, using local.', e);
        $('#tokenPro').innerHTML = cardToken({ name: 'ETH', symbol: 'eth', current_price: 2000, price_change_percentage_24h: 5 }).outerHTML;
      }
    }

    function cardToken(t) {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `<b>${t.name}</b><div class="muted">$${t.current_price} (${t.price_change_percentage_24h.toFixed(2)}%)</div>
        <div class="row"><button class="btn" data-sym="${t.symbol.toUpperCase()}">Ph√¢n t√≠ch</button><button class="btn out" data-stake>Stake</button></div>`;
      return card;
    }

    // Premium content
    function paintPremium() {
      $('#premium').classList.add('unlocked');
      $('#premium').style.display = 'block';
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `<b>Ch√†o m·ª´ng Premium!</b><div class="muted">Ph√¢n t√≠ch, NFT & Cosmic Game</div><button class="btn" onclick="relock()">Tho√°t Premium</button>`;
      $('#premium').appendChild(card);
      cosmicGame();
    }

    // Chat
    function addBubble(text, who) {
      const div = document.createElement('div');
      div.className = `bubble ${who}`;
      div.textContent = text;
      $('#chatBody').appendChild(div);
      $('#chatBody').scrollTop = $('#chatBody').scrollHeight;
    }

    $('#chatInput').onkeypress = async e => {
      if (e.key === 'Enter' && $('#chatInput').value.trim()) {
        const query = $('#chatInput').value;
        addBubble(query, 'me');
        $('#chatInput').value = '';
        localStorage.setItem('userEvents', JSON.stringify([...JSON.parse(localStorage.getItem('userEvents') || '[]'), { type: 'keyword', target: query, time: Date.now() }]));
        if (await initAI()) {
          try {
            const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
              body: JSON.stringify({
                model: 'grok-3',
                messages: [{ role: 'user', content: query }],
                max_tokens: 1000,
                temperature: 0.2
              })
            });
            const data = await res.json();
            addBubble(data.choices[0].message.content, 'ai');
          } catch (e) { addBubble(localAI(query), 'ai'); }
        } else {
          addBubble(localAI(query), 'ai');
        }
      }
    };

    // Token analysis
    async function aiAnalyzeToken(symbol) {
      if (await initAI()) {
        try {
          const res = await fetch(st.cfg.ai_api_url + '/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
            body: JSON.stringify({
              model: 'grok-3',
              messages: [{ role: 'user', content: `Ph√¢n t√≠ch token ${symbol} v·ªõi FOMO triggers v√† chi·∫øn l∆∞·ª£c giao d·ªãch.` }],
              max_tokens: 1000
            })
          });
          const data = await res.json();
          const analysis = data.choices[0].message.content;
          addBubble(analysis, 'ai');
          if (localStorage.getItem('premium_unlocked') === '1') {
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `<b>Ph√¢n t√≠ch ${symbol}</b><div class="muted">${analysis}</div>`;
            $('#premium').appendChild(card);
          }
        } catch (e) { addBubble(localAI('ph√¢n t√≠ch'), 'ai'); }
      } else {
        addBubble(localAI('ph√¢n t√≠ch'), 'ai');
      }
    }

    // Auto revenue
    async function autoRevenue() {
      if (!signer) return;
      try {
        const lidoContract = new ethers.Contract(
          '0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84',
          ['function submit(address _referral) payable returns (uint256)'],
          signer
        );
        const tx = await lidoContract.submit(st.cfg.payments.eth.id, { value: ethers.utils.parseEther('0.01') });
        await tx.wait();
        st.rev += 0.01 * 1000;
        localStorage.setItem('rev', st.rev);
        addBubble('Auto-staked 0.01 ETH on Lido!', 'me');
      } catch (e) { console.warn('Auto staking failed', e); }
    }

    // Dynamic NFT
    async function dynamicNFT() {
      const keywords = JSON.parse(localStorage.getItem('userEvents') || '[]').slice(-1)[0]?.target || 'FOMO';
      const meta = (await initAI()) ? 
        JSON.parse((await (await fetch(st.cfg.ai_api_url + '/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${st.cfg.ai_api_key}` },
          body: JSON.stringify({
            model: 'grok-3',
            messages: [{ role: 'user', content: `Generate NFT metadata for keyword "${keywords}". Include name, image URL, FOMO description.` }],
            max_tokens: 1000
          })
        })).json().then(d => d.choices[0].message.content)) :
        { name: `${keywords} Cosmic Star`, image: 'https://ipfs.io/ipfs/Qm...', description: `Own the ${keywords} trend! Limited drop!` };
      const nftCard = document.createElement('div');
      nftCard.className = 'card';
      nftCard.innerHTML = `<b>${meta.name}</b><img src="${meta.image}" style="width:100%;border-radius:12px">
      <div class="muted">${meta.description}</div><button class="btn">Mint NFT</button>`;
      nftCard.querySelector('button').onclick = async () => {
        if (st.cfg.nft_contract === '0xYOUR_NFT_CONTRACT_ADDRESS') return;
        const nftContract = new ethers.Contract(st.cfg.nft_contract, ['function mint(string memory uri)'], signer);
        const tx = await nftContract.mint(JSON.stringify(meta));
        await tx.wait();
        addBubble(`Minted NFT for ${keywords}!`, 'me');
      };
      $('#premium').appendChild(nftCard);
    }

    // Cosmic game
    async function cosmicGame() {
      const block = await provider.getBlock('latest');
      const seed = parseInt(block.hash.slice(-8), 16);
      const rand = (seed % 100) / 100;
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `<b>Cosmic Game</b><div class="muted">${rand > 0.5 ? 'Collect stars to earn 0.01 ETH!' : 'Spin for a rare NFT!'}</div><button class="btn" onclick="playCosmic()">Ch∆°i ngay</button>`;
      $('#premium').appendChild(card);
    }

    async function playCosmic() {
      const block = await provider.getBlock('latest');
      const seed = parseInt(block.hash.slice(-8), 16);
      const rand = (seed % 100) / 100;
      addBubble(rand > 0.7 ? 'You won 0.01 ETH!' : 'Try again for a rare NFT!', 'ai');
      if (rand > 0.7) {
        const tx = await signer.sendTransaction({
          to: st.cfg.payments.eth.id,
          value: ethers.utils.parseEther('0.01')
        });
        await tx.wait();
        st.rev += 0.01 * 1000;
        localStorage.setItem('rev', st.rev);
      }
    }

    // Self-evolving DOM
    function selfEvolve() {
      const events = JSON.parse(localStorage.getItem('userEvents') || '[]');
      if (events.length > 10) {
        const styleEl = document.createElement('style');
        styleEl.textContent = `.card { border: 2px solid ${events.length % 2 ? 'var(--gold)' : 'var(--blue)'}; }`;
        document.head.appendChild(styleEl);
      }
    }

    // Psychological triggers
    function psychologicalTriggers() {
      const events = JSON.parse(localStorage.getItem('userEvents') || '[]');
      const keywords = events.slice(-1)[0]?.target || 'FOMO';
      $('#ticker').textContent = `üöÄ ${keywords.toUpperCase()} ƒëang b√πng n·ªï! ƒê·ª´ng b·ªè l·ª°!`;
      const styleEl = document.createElement('style');
      styleEl.textContent = `.btn { animation: bounce 1s infinite; } @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }`;
      document.head.appendChild(styleEl);
    }

    // 3D Globe
    try {
      const canvas = document.getElementById('globe3d');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      const DPR = Math.min(window.devicePixelRatio || 1, 2);
      const W = canvas.clientWidth || 300, H = canvas.clientHeight || 300;
      renderer.setPixelRatio(DPR); renderer.setSize(W, H, false);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, W/H, 0.1, 100); camera.position.z = 6;

      const ambient = new THREE.AmbientLight(0x1E90FF, 0.6);
      const sun = new THREE.DirectionalLight(0xFFD700, 0.8);
      sun.position.set(6, 3, 4);
      scene.add(ambient, sun);

      const loader = new THREE.TextureLoader();
      const earthTex = loader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
      const normalTx = loader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg');
      const specTx = loader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg');
      const cloudTx = loader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png');
      const moonTex = loader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg');

      const earth = new THREE.Mesh(
        new THREE.SphereGeometry(2.4, 64, 64),
        new THREE.MeshPhongMaterial({
          map: earthTex,
          bumpMap: normalTx,
          bumpScale: 0.04,
          specularMap: specTx,
          specular: new THREE.Color(0x27AE60),
          shininess: 20
        })
      );
      scene.add(earth);

      const tint = new THREE.Mesh(
        new THREE.SphereGeometry(2.405, 64, 64),
        new THREE.MeshBasicMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.2 })
      );
      scene.add(tint);

      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(2.46, 64, 64),
        new THREE.MeshLambertMaterial({ map: cloudTx, transparent: true, opacity: 0.45 })
      );
      scene.add(clouds);

      const moon = new THREE.Mesh(
        new THREE.SphereGeometry(0.65, 32, 32),
        new THREE.MeshStandardMaterial({ map: moonTex, roughness: 1, metalness: 0 })
      );
      const moonLight = new THREE.PointLight(0xFFD700, 1.2, 18);
      const moonGroup = new THREE.Group();
      moonGroup.add(moon, moonLight);
      scene.add(moonGroup);

      function resize() {
        const w = canvas.clientWidth || 300, h = canvas.clientHeight || 300;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize);

      let t = 0;
      function animate() {
        requestAnimationFrame(animate);
        earth.rotation.y += 0.002;
        tint.rotation.y += 0.002;
        clouds.rotation.y += 0.0025;
        t += 0.002;
        const r = 5.2;
        moonGroup.position.set(Math.cos(t) * r, Math.sin(t * 1.1) * 0.8, Math.sin(t) * r * 0.4);
        moonLight.position.set(0, 0, 0);
        renderer.render(scene, camera);
      }
      animate();
    } catch (e) { console.warn('WebGL not available, fallback static.', e); }

    // Initialize
    (async () => {
      autoBeautify();
      autoViral();
      fetchRealtimeTokens();
      selfEvolve();
      psychologicalTriggers();
      if (localStorage.getItem('premium_unlocked') === '1') {
        dynamicNFT();
        autoRevenue();
        cosmicGame();
      }
      if (await initAI()) {
        autoBeautify();
        autoViral();
        psychologicalTriggers();
      }
      setInterval(autoViral, 1800000);
      setInterval(selfEvolve, 60000);
      setInterval(psychologicalTriggers, 300000);
      remember();
    })();
  </script>
</body>
</html>
